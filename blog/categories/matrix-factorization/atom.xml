<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: matrix-factorization | LESS IS MORE]]></title>
  <link href="http://r9y9.github.io/blog/categories/matrix-factorization/atom.xml" rel="self"/>
  <link href="http://r9y9.github.io/"/>
  <updated>2014-09-30T01:40:15+09:00</updated>
  <id>http://r9y9.github.io/</id>
  <author>
    <name><![CDATA[Ryuichi YAMAMOTO]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[調波打楽器音分離（HPSS）を試す]]></title>
    <link href="http://r9y9.github.io/blog/2013/09/14/hpss/"/>
    <updated>2013-09-14T23:34:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2013/09/14/hpss</id>
    <content type="html"><![CDATA[<h2>HPSSとは（一行説明）</h2>

<p>HPSS（Harmonic/Percussive Sound Separation）というのは、音源中の調波音/打楽器音が、それぞれ時間方向に滑らか/周波数方向に滑らかという異った性質を持つことを利用して、両者を分離する方法のこと。わからんければ論文へ</p>

<p>アイデアはシンプル、実装は簡単、効果は素晴らしい。specmurtに似たものを感じる。ということで少し感動したので結果を載せる</p>

<h2>実装</h2>

<p>調波音のスペクトログラムを$H$、打楽器音のスペクトログラムを$P$、時間indexをt、周波数indexをkとして、以下の数式をそのまま実装して、適当に反復計算すればおｋ</p>

<p><script type="math/tex; mode=display">
\begin{align}
|H<em>{t, k}| = \frac{w</em>{H}^2 (|H<em>{t+1,k}| + |H</em>{t-1,k}|)<sup>2</sup> |W<em>{t,k}|}{w</em>{H}^2 (|H<em>{t+1,k}| + |H</em>{t-1,k}|)<sup>2</sup> + w<em>{P}^2(|P</em>{t,k+1}| + |P_{t,k-1}|)<sup>2</sup>}
\end{align}
</script></p>

<p><script type="math/tex; mode=display">
\begin{align}
|P<em>{t, k}| = \frac{w</em>{P}^2 (|P<em>{t,k+1}| + |P</em>{t,k-1}|)<sup>2</sup> |W<em>{t,k}|}{w</em>{H}^2 (|H<em>{t+1,k}| + |H</em>{t-1,k}|)<sup>2</sup> + w<em>{P}^2(|P</em>{t,k+1}| + |P_{t,k-1}|)<sup>2</sup>}
\end{align}
</script></p>

<p>ただし
<script type="math/tex; mode=display">
\begin{align}
|W<em>{t,k}| = |H</em>{t,k}| + |P_{t,k}|
\end{align}
</script></p>

<p>絶対値はパワースペクトル。論文中の表記とはけっこう違うので注意。厳密ではないです。$w_{H}, w_{P}$は重み係数で、両方共1.0くらいにしとく。</p>

<p>HPSSの論文はたくさんあるけど、日本語でかつ丁寧な <a href="http://ci.nii.ac.jp/naid/110007997346">&ldquo;スペクトルの時間変化に基づく音楽音響信号からの歌声成分の強調と抑圧&rdquo;</a> を参考にした。</p>

<p>H/Pから音源を再合成するときは、位相は元の信号のものを使えばおｋ</p>

<p>一点だけ、HとPの初期値どうすればいいんかなぁと思って悩んだ。まぁ普通に元音源のスペクトログラムを両方の初期値としてやったけど、うまく動いてるっぽい。</p>

<h2>結果</h2>

<p>フリー音源でテストしてみたので、結果を貼っとく。$w_{H}=1.0, w_{P}=1.0$、サンプリング周波数44.1kHz、モノラル、フレーム長512、窓関数はhanning。反復推定の回数は30。音源は、<a href="http://maoudamashii.jokersounds.com/archives/song_kyoko_feels_happiness.html">歌もの音楽素材：歌入り素材系のフリー音楽素材一覧</a> から使わせてもらいました。ありがとうございまっす。元音源だけステレオです。
18秒目くらいからを比較すると効果がわかりやすいです</p>

<h3>元音源</h3>

<iframe frameborder="no" height="166" scrolling="no" src="https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110367442" width="100%"></iframe>


<h3>Hのみ取り出して再合成した音源</h3>

<iframe frameborder="no" height="166" scrolling="no" src="https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110367534" width="100%"></iframe>


<h3>Pのみ取り出して再合成した音源</h3>

<iframe frameborder="no" height="166" scrolling="no" src="https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110367599" width="100%"></iframe>


<p>それにしても特に泥臭い努力をせずに、このクオリティーが出せるのはすごい。音源に対する事前知識も何もないし。あと、ちょっとノイズが載ってるのはたぶんプログラムミス。つらたーん</p>

<p>コレ以外にも多重HPSSとかもやったけど、いやーおもしろい手法だなーと思いました（こなみ</p>

<p>詳しくは論文へ（僕のじゃないけど</p>

<h2>参考</h2>

<ul>
<li><a href="http://ci.nii.ac.jp/naid/110007997346">橘 秀幸, 小野 順貴, 嵯峨山 茂樹, &ldquo;スペクトルの時間変化に基づく音楽音響信号からの歌声成分の強調と抑圧&rdquo;, 情報処理学会研究報告, vol. 2009-MUS-81(12), pp. 1-6, 2009.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NMFアルゴリズムの導出（ユークリッド距離版）]]></title>
    <link href="http://r9y9.github.io/blog/2013/07/27/nmf-euclid/"/>
    <updated>2013-07-27T23:30:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2013/07/27/nmf-euclid</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p>シングルトラックにミックスダウンされた音楽から、その構成する要素（例えば、楽器とか）を分離したいと思うことがある。
音源分離と言えば、最近はNon-negative Matrix Factorization (非負値行列因子分解; NMF) が有名。
実装は非常に簡単だけど、実際にやってみるとどの程度の音源分離性能が出るのか気になったので、やってみる。</p>

<p>と思ったけど、まずNMFについて整理してたら長くなったので、実装は今度にして、まずアルゴリズムを導出してみる。</p>

<h2>NMFの問題設定</h2>

<p>NMFとは、与えられた行列を非負という制約の元で因子分解する方法のこと。
音楽の場合、対象はスペクトログラムで、式で書くとわかりやすい。
スペクトログラムを <script type="math/tex"> \mathbf{Y}: [\Omega \times T] </script>
とすると、
<script type="math/tex; mode=display">
\begin{align}
\mathbf{Y} \simeq \mathbf{H} \mathbf{U}
\end{align}
</script></p>

<p>となる、<script type="math/tex">\mathbf{H}: [\Omega \times K]、\mathbf{U}: [K \times T]</script>を求めるのがNMFの問題。
ここで、Hが基底、Uがアクティビティ行列に相当する。
NMFは、元の行列Yと分解後の行列の距離の最小化問題として定式化できる。</p>

<p><script type="math/tex; mode=display">
\begin{align}
\mathbf{H}, \mathbf{U} = \mathop{\rm arg~min}\limits<em>{\mathbf{H}, \mathbf{U}} D (\mathbf{Y}|\mathbf{H}\mathbf{U}), \hspace{3mm} {\rm subect\ to} \hspace{3mm} H</em>{\omega,k}, U_{k, t} > 0
\end{align}
</script></p>

<p>すごくシンプル。Dは距離関数で色んなものがある。ユークリッド距離、KLダイバージェンス、板倉斎藤距離、βダイバージェンスとか。</p>

<h2>ユークリッド距離の最小化</h2>

<p>ここではユークリッド距離（Frobeniusノルムともいう）として、二乗誤差最小化問題を解くことにする。
一番簡単なので。最小化すべき目的関数は次のようになる。
<script type="math/tex; mode=display">
\begin{align}
D (\mathbf{Y}|\mathbf{H}\mathbf{U}) =&amp; || \mathbf{Y}&ndash;\mathbf{HU}||<em>{F} \
=&amp; \sum</em>{\omega, k}|Y<em>{\omega,t} &ndash; \sum</em>{k}H<em>{\omega, k}U</em>{k, t}|^{2}
\end{align}
</script></p>

<p>行列同士の二乗誤差の最小化は、要素毎の二乗誤差の和の最小化ということですね。展開すると、次のようになる。
<script type="math/tex; mode=display">
\begin{align}
\sum<em>{\omega, k}|Y</em>{\omega,t} &ndash; \sum<em>{k}H</em>{\omega, k}U<em>{k, t}|^{2}
= \sum</em>{\omega, t}(|Y<em>{\omega, t}|^2 -2Y</em>{\omega, t} \sum<em>{k}H</em>{\omega, k}U<em>{k, t} + |\sum</em>{k}H<em>{\omega, k}U</em>{k, t}|^2)
\end{align}
</script>
微分してゼロ！としたいところだけど、3つ目の項を見ると、絶対値の中に和が入っているので、そうはいかない。
なので、補助関数法を使う。
基本的なアイデアは、目的関数の直接の最適化が難しい場合には、上界関数を立てることで間接的に最小化するということ。</p>

<p>3項目に対してイェンセンの不等式を適応すると、
<script type="math/tex; mode=display">
\begin{align}
|\sum<em>{k}H</em>{\omega,k}U<em>{k,t}|^{2} \le \sum</em>{k} \frac{H<em>{\omega,k}^{2}U</em>{k, t}^{2}}{\lambda_{k, \omega, t}}
\end{align}
</script></p>

<p>これで、右辺は <script type="math/tex"> H_{\omega,k}, U_{k, t} </script> について二次関数になったので、微分できてはっぴー。
上の不等式を使えば、実際に最小化する目的関数は、次のようになる。</p>

<p><script type="math/tex; mode=display">
\begin{align}
G := \sum<em>{\omega, t}(|Y</em>{\omega, t}|^2 -2Y<em>{\omega, t} \sum</em>{k}H<em>{\omega, k}U</em>{k, t} + \sum<em>{k} \frac{H</em>{\omega,k}^{2}U<em>{k, t}^{2}}{\lambda</em>{k, \omega, t}})
\end{align}
</script>
Gを最小化すれば、間接的に元の目的関数も小さくなる。</p>

<h2>更新式の導出</h2>

<p>あとは更新式を導出するだけ。
まず、目的関数を上から押さえるイメージで、イェンセンの不等式の等号条件から補助変数の更新式を求める。
この場合、kに関して和が1になることに注意して、</p>

<p><script type="math/tex; mode=display">
\begin{align}
\lambda<em>{k,\omega,t} = \frac{H</em>{\omega, k}U<em>{k, t}}{\sum</em>{k'}H<em>{\omega, k'}U</em>{k', t}}
\end{align}
</script></p>

<p>次に、目的関数Gを<script type="math/tex">H_{\omega,k}, U_{k,t} </script>で偏微分する。</p>

<p><script type="math/tex; mode=display">
\begin{align}
\frac{\partial G}{\partial H<em>{\omega,k}} &amp;= \sum</em>{t} (-2 Y<em>{\omega,t}U</em>{k,t} + 2 \frac{H<em>{\omega, k}U</em>{k, t}^2}{\lambda<em>{k,\omega,t}}) &amp;= 0\
\frac{\partial G}{\partial U</em>{k, t}} &amp;= \sum<em>{\omega} (-2 Y</em>{\omega,t}H<em>{\omega,k} + 2 \frac{H</em>{\omega, k}^2U<em>{k, t}}{\lambda</em>{k,\omega,t}}) &amp;= 0
\end{align}
</script></p>

<p>少し変形すれば、以下の式を得る。</p>

<p><script type="math/tex; mode=display">
\begin{align}
H<em>{\omega,k} = \frac{\sum</em>{t}Y<em>{\omega,t}U</em>{k,t}}{\sum<em>{t}\frac{U</em>{k, t}^2}{\lambda<em>{k,\omega,t}}}, \hspace{3mm}
U</em>{k,t} = \frac{\sum<em>{\omega}Y</em>{\omega,t}H<em>{\omega,k}}{\sum</em>{\omega}\frac{H<em>{\omega, k}^2}{\lambda</em>{k,\omega,t}}}
\end{align}
</script></p>

<p>補助変数を代入すれば、出来上がり。
<script type="math/tex; mode=display">
\begin{align}
H<em>{\omega,k} = H</em>{\omega,k} \frac{\sum<em>{t}Y</em>{\omega,t}U<em>{k,t}}{\sum</em>{t}U<em>{k, t}\sum</em>{k'}H<em>{\omega, k'}U</em>{k', t}}, \hspace{3mm}
U<em>{k,t} = U</em>{k,t}\frac{\sum<em>{\omega}Y</em>{\omega,t}H<em>{\omega,k}}{\sum</em>{\omega}H<em>{\omega, k}\sum</em>{k'}H<em>{\omega, k'}U</em>{k', t}}
\end{align}
</script></p>

<h2>行列表記で</h2>

<p>これで終わり…ではなく、もう少しスマートに書きたい。
ここで、少し実装を意識して行列表記を使って書きなおす。
行列の積は、AB（A: [m x n] 行列、B: [n x l] 行列）のようにAの列数とBの行数が等しくなることに注意して、
ほんの少し変形すれば最終的には次のように書ける。</p>

<p><script type="math/tex; mode=display">
\begin{align}
H<em>{\omega,k} &amp;= H</em>{\omega,k} \frac{[\mathbf{Y}\mathbf{U}^{\mathrm{T}}]<em>{\omega,k}}{[\mathbf{H}\mathbf{U}\mathbf{U}^{\mathrm{T}}]</em>{\omega,k}}, \
U<em>{k,t} &amp;= U</em>{k,t}\frac{[\mathbf{H}^{\mathrm{T}}\mathbf{Y}]<em>{k, t}}{[\mathbf{H}^{\mathrm{T}}\mathbf{H}\mathbf{U}]</em>{k,t}}
\end{align}
</script></p>

<p>乗法更新式というやつですね。
元々の行列の要素が非負なら、掛けても非負のままですよってこと。
NMFのアルゴリズムは、この更新式を目的関数が収束するまで計算するだけ、簡単。Pythonなら数行で書ける。</p>

<h2>メモ</h2>

<p>自分で導出していて思ったことをメモっておこうと思う。</p>

<ul>
<li>更新式は、行列の要素毎に独立して求められるんだなぁということ。

<ul>
<li>まぁ要素毎に偏微分して等式立ててるからそうなんだけど。更新の順番によって、収束する値、速度が変わるといったことはないんだろうか。</li>
</ul>
</li>
<li>行列演算とスカラー演算が同じ式に同時に含まれていることがあるので注意。例えば、最終的な更新式の割り算は、要素毎のスカラー演算で、行列演算ではない。</li>
<li>何かいっぱいシグマがあるけど、めげない。計算ミスしやすい、つらい。</li>
<li>NMFという名前から行列操作を意識してしまうけど、更新式の導出の過程に行列の微分とか出てこない。更新式の導出は、行列の要素個々に対して行うイメージ。</li>
</ul>


<p>NMFなんて簡単、と言われますが（要出典）、実際にやってみると結構めんどくさいなー、と思いました（小並感</p>
]]></content>
  </entry>
  
</feed>
