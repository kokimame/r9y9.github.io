<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: julia | LESS IS MORE]]></title>
  <link href="http://r9y9.github.io/blog/categories/julia/atom.xml" rel="self"/>
  <link href="http://r9y9.github.io/"/>
  <updated>2015-12-08T00:50:33+09:00</updated>
  <id>http://r9y9.github.io/</id>
  <author>
    <name><![CDATA[Ryuichi YAMAMOTO]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最近の音声信号処理遊びの進捗]]></title>
    <link href="http://r9y9.github.io/blog/2015/08/23/speech-analysis-and-synthesis-in-julia/"/>
    <updated>2015-08-23T16:35:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/08/23/speech-analysis-and-synthesis-in-julia</id>
    <content type="html"><![CDATA[<h2>hello</h2>

<p>遡ればもう約一年まえになるでしょうか、統計的声質遊びをしたいと思い、理論の勉強を始めたり、（特にJuliaで）コードを色々書いていました（お前ほんといろんな言語で遊んでるな、というツッコミはさておき）。<a href="http://r9y9.github.io/blog/2014/11/12/statistical-voice-conversion-code/">統計的声質変換クッソムズすぎワロタ（チュートリアル編） &ndash; LESS IS MORE</a> を書いていた当初は、当然自分のためだけに書いていて、まぁアレな出来でしたが、最近気を取り直して多少マシに仕上げましたので、何となくブログに書いてみようかなーと思った次第です。というわけで、最近公式に登録したいくつかのパッケージを、まとめて簡単に紹介します。</p>

<p>主な改善点は、windowsもちゃんとサポートするようにしたこと（誰得？）と、テストをきちんと書いたことと、julia的なインタフェースを意識するようにしたことですかね。3つ目はかなり曖昧ですが、まぁ気持ち使いやすくなったと思います。</p>

<h2>パッケージ</h2>

<ul>
<li><a href="https://github.com/r9y9/MelGeneralizedCepstrums.jl">MelGeneralizedCepstrums.jl</a>: メル一般化ケプストラム分析</li>
<li><a href="https://github.com/r9y9/SynthesisFilters.jl">SynthesisFilters.jl</a>: メル一般化ケプストラムからの音声波形合成</li>
<li><a href="https://github.com/r9y9/SPTK.jl">SPTK.jl</a>: <a href="http://sp-tk.sourceforge.net/">SPTK</a>のラッパー</li>
</ul>


<p>車輪の再発明はできるだけしたくなかったので、最初のほうはCライブラリのラッパーを書くことが多く、windowsとかめんどくさいしunix環境でしか動作確認してませんでしたが、<a href="http://qiita.com/r9y9/items/e0567e2a21a5e3c36e51">WindowsのJuliaから呼べるようなCライブラリの共有ライブラリ（DLL）を作る | qiita</a> 重い腰を上げてwindowsでも動くように頑張ったことがあり（めんどくさいとか言って手を動かさないのホント良くないですね）、登録したパッケージはすべてwindowsでも動くようになりました。めでたし。<a href="https://github.com/r9y9/WORLD.jl">WORLD.jl</a> もwindowsで動くようにしました。</p>

<h2>MelGeneralizedCepstrums.jl</h2>

<p>メルケプストラムの推定とか。いくつか例を載せておきます</p>

<p><img class="center <a" src="href="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/cepstrum.png">https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/cepstrum.png</a>" title="&ldquo;cepstrum based envelope.&rdquo;" ></p>

<p><img class="center <a" src="href="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-cepstrum.png">https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-cepstrum.png</a>" title="&ldquo;mel-cepstrum based envelope.&rdquo;" ></p>

<p><img class="center <a" src="href="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-generalized-cepstrum.png">https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-generalized-cepstrum.png</a>" title="&ldquo;mel-generalized-cepstrum based envelope.&rdquo;" ></p>

<p><img class="center <a" src="href="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/lpc-cepstrum.png">https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/lpc-cepstrum.png</a>" title="&ldquo;lpc-cepstrum based envelope.&rdquo;" ></p>

<p>詳細はこちらの<a href="http://nbviewer.ipython.org/github/r9y9/MelGeneralizedCepstrums.jl/blob/v0.0.1/examples/Introduction%20to%20MelGeneralizedCeptrums.jl.ipynb">ノートブック</a>へ</p>

<p>メルケプストラム分析、メル一般化ケプストラム分析に関しては、SPTKの実装をjuliaで再実装してみました。結果、速度は1.0 ~ 1.5倍程度でおさまって、かつ数値的な安定性は増しています（メモリ使用量はお察し）。まぁ僕が頑張ったからというわけでなく、単にJuliaの線形方程式ソルバーがSPTKのものより安定しているというのが理由です。</p>

<h2>SynthesisFilters.jl</h2>

<p>メルケプストラムからの波形合成とか。</p>

<p>詳細はこちらの<a href="http://nbviewer.ipython.org/github/r9y9/SynthesisFilters.jl/blob/v0.0.1/examples/Introduction%20to%20SynthesisFilters.jl.ipynb">ノートブック</a>へ。いくつかの音声合成フィルタの合成音をノートブック上で比較することができます。</p>

<p><a href="http://nbviewer.ipython.org/github/r9y9/SynthesisFilters.jl/blob/mix-excitation/examples/Introduction%20to%20SynthesisFilters.jl.ipynb">mixed excitation（っぽいの）を使ったバージョンのノートブック</a>: 実装に自信がないので、そのうち消すかも。聴覚的にはこっちのほうが良いです。</p>

<h2>SPTK.jl</h2>

<p>公式のSPTKではなく、僕が少しいじったSPTK（windowsで動くようにしたり、APIとして使いやすいように関数内でexitしてた部分を適切なreturn code返すようにしたり、swipeというF0抽出のインタフェースをexposeしたり、など）をベースにしています。</p>

<p><a href="http://nbviewer.ipython.org/github/r9y9/SPTK.jl/blob/v0.0.1/examples/Introduction%20to%20SPTK.jl.ipynb">デモ用のノートブック</a></p>

<p>MelGeneralizedCepstrums.jl と SynthesiFilters.jl は、ほとんどSPTK.jlで成り立っています。本質的に SPTK.jl にできて MelGeneralizedCepstrums.jl と SynthesiFilters.jlにできないことは基本的にないのですが、後者の方が、より簡単な、Julia的なインタフェースになっています。</p>

<p>例えば、メルケプストラム、ケプストラム、LPCなど、スペクトルパラメータの型に応じて、適切なフィルタ係数に変換する、合成フィルタを選択するなど、multiple dispatchを有効に活用して、よりシンプルなインタフェースを提供するようにしました（というか自分がミスりたくなかったからそうしました）。</p>

<h2>おわり</h2>

<p>かなり適当に書きましたが、最近の進捗は、Juliaで書いていたパッケージ多少改善して、公式に登録したくらいでした。進捗まじ少なめ。あと些細なことですが、ipython（ijulia）に音埋め込むのクッソ簡単にできてびっくりしました（なんで今までやらなかったんだろう）。<a href="https://github.com/jfsantos">@jfsantos</a> に感謝</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ccallにおけるポインタ周りのハマりどころとその解決法]]></title>
    <link href="http://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips/"/>
    <updated>2014-12-09T02:20:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/advent-calendar/2014/julialang">Julia Advent Calendar 2014</a> 9日目の記事です。</p>

<h2>はじめに</h2>

<p>CやFortranの関数をJuliaから呼ぶために使用する<code>ccall</code>において、ポインタに関係するハマりどころとその解決法を紹介します。純粋なJuliaを使っている場合にはポインタを意識することはめったにないと思うので、<code>ccall</code> を使う人（計算が重いボトルネック部分をCで書いてJuliaから呼びたい人、Cのライブラリのラッパーを書きたい/書いてる人）を主な読者と想定して記事を書きました（限定的でごめんなさい）。</p>

<p>困った時は、公式ドキュメントの <a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a> を参考にしましょう。</p>

<p><strong>注意</strong>: 最新版の公式ドキュメントをいくつか引用していますが、ドキュメントは日々更新されていますので、この記事を読んで頂いた時点とは異なる可能性があることにご注意ください。</p>

<h2>こんなとき</h2>

<p><code>ccall</code> を使う際に、ポインタに関する以下のような疑問を持つことがあります。</p>

<ul>
<li>ポインタを引数に持つ（例. <code>double*</code>）関数のラッピングはどうすればいいのか？</li>
<li>構造体のポインタを引数に持つ関数のラッピングはどうすれば？</li>
<li>ポインタのポインタを引数に持つ（例. <code>double**</code>）関数のラッピングは？</li>
</ul>


<p>一つ目は非常に簡単で、<code>Array</code>（Cの関数が<code>double*</code>を取るならば<code>Array{Float64,1}</code>）をそのまま渡せばよいだけです。ドキュメントの<a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/#array-conversions">Array Conversions</a>にも書かれています。が、残りの二つに関してはハマりどころがあります。順に説明します。</p>

<h2>構造体のポインタを引数に持つ関数のラッピングはどうすれば？</h2>

<p>現状のドキュメントは少し不親切なので、引用した上で、整理します。</p>

<p><a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a> より引用:</p>

<blockquote><p>Currently, it is not possible to pass structs and other non-primitive types from Julia to C libraries. However, C functions that generate and use opaque struct types by passing pointers to them can return such values to Julia as Ptr{Void}, which can then be passed to other C functions as Ptr{Void}. Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program.</p></blockquote>

<p>冒頭に it is not possible とあります。が、決して不可能なわけではありません。上記文章の要点をまとめると、</p>

<ul>
<li>opaqueな構造体はCからJuliaへポインタとして渡すことができる</li>
<li>そのポインタは <code>Ptr{Void}</code> としてCの関数に渡すことができる</li>
</ul>


<p>と書かれています。つまり、一般には構造体は渡せないけどポインタ渡しはできるよ、ということです。</p>

<p>じゃあnon-opaqueな構造体についてはどうなんだ？Juliaの型を渡せないのか？という疑問が出てきます。結論からいえば、non-opaqueな構造体についてもポインタ渡しは可能です。つまり、Cの構造体に相当するimmutableな型<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>をjuliaで宣言してあげれば、juliaの型をCに渡すことが可能です（値渡しはできません）</p>

<p>例を示します。</p>

<h3>Cコード</h3>

<p>```c
typedef struct {
   double a;
   int b;
} Foo;</p>

<h1>構造体のポインタを引数にとる関数1</h1>

<p>void print(Foo* foo) {</p>

<pre><code>printf("a=%lf\n", foo-&gt;a);
printf("b=%d\n", foo-&gt;b);
</code></pre>

<p>}</p>

<h1>構造体のポインタを引数にとる関数2</h1>

<p>void reset(Foo* foo) {</p>

<pre><code>foo-&gt;a = 0.0;
foo-&gt;b = 0;
</code></pre>

<p>}
```</p>

<h3>Juliaコード</h3>

<p>```julia</p>

<h1>Cの構造体 Foo に相当する型を宣言します</h1>

<p>immutable Foo</p>

<pre><code>a::Float64
b::Int32 # cのintはjuliaのInt32に対応します
</code></pre>

<p>end</p>

<p>foo = Foo(10.0, 2)</p>

<h1>Cの関数に、ポインタとしてJuliaの型を渡すことができます</h1>

<p>ccall(:print, &ldquo;libfoo&rdquo;, Void, (Ptr{Foo},), &amp;foo)</p>

<h1>ポインタで渡す場合、Cで変更した結果はJuliaにも反映されます</h1>

<p>ccall(:reset, &ldquo;libfoo&rdquo;, Void, (Ptr{Foo},), &amp;foo)</p>

<h1>foo(0.0, 0) と表示される</h1>

<p>println(foo)
```</p>

<p>ちなみにJuliaからCへ値渡しをしてもエラーにならないので、お気をつけください（ハマりました）。</p>

<p>公式ドキュメントは不親切と言いましたが、 プルリクエスト <a href="https://github.com/JuliaLang/julia/pull/8948">update documentation for passing struct pointers to C #8948</a>（まだマージはされていない）で改善されているので、もしかするとこの記事が読まれる頃には改善されているかもしれません。</p>

<p>また、値渡しを可能にしようとする動きもあります（<a href="https://github.com/JuliaLang/julia/pull/3466">RFC: Make struct passing work properly #3466</a>, <a href="https://github.com/JuliaLang/julia/pull/2818">WIP: types as C-structs #2818</a> マージ待ち）。</p>

<h3>構造体渡しのまとめ</h3>

<ul>
<li>Cの構造体に相当するJuliaの型を定義して、ポインタで渡せばOK</li>
<li>値渡しは現状できない</li>
<li>ポインタを受けることはできる（Ptr{Void}として受ける）</li>
</ul>


<h2>ポインタのポインタを引数に持つ（例. <code>double**</code>）関数のラッピングは？</h2>

<p>さて、これはドキュメントにまったく書かれておらず、かつハマりやすいと僕は思っています。例を交えつつ解説します。以下のような関数のラッピングを考えます。</p>

<p><code>c
void fooo(double** input, int w, int h, double** output);
</code></p>

<p><code>input</code>は入力の行列、<code>output</code>は計算結果が格納される行列、行列のサイズは共に 列数<code>w</code>、行数<code>h</code> だと思ってください。Juliaからは <code>input::Array{Float64,2}</code> を入力として、<code>output::Array{Float64,2}</code> を得たいとします。</p>

<p><code>double*</code>を引数にとる場合は<code>Array{Float64,1}</code>を渡せばよかったのに対して、<code>double**</code>を引数に取る関数に <code>Array{Float64,2}</code>や<code>Array{Array{Float64,1},1}</code>を単純に渡すだけでは、残念ながらコンパイルエラーになります。はい、すでに若干面倒ですね。。さて、どうすればいいかですが、</p>

<ul>
<li>どんな型で渡せばいいか</li>
<li>どのように型を変換するか</li>
<li>変換した型をどのように元に戻すか</li>
</ul>


<p>という三点に分けて説明します。</p>

<h3>1. どんな型で渡せばいいか</h3>

<p><code>Array{Ptr{Float64}}</code> で渡せばよいです。外側のArrayは、<code>ccall</code> がポインタに変換してくれるので、Juliaの型でいえば<code>Ptr{Ptr{Float64}}</code>、Cの型で言えば<code>double**</code>になるわけです。</p>

<h3>2. どのように型を変換するか</h3>

<p>ここがハマりどころです。今回の例では、<code>Array{Float64,2}</code> を <code>Array{Ptr{Float64},1}</code> に変換すればよいので、例えば以下のような実装が思いつきます。</p>

<p>```julia</p>

<h1>Array{T,2} &ndash;> Array{Ptr{T}}</h1>

<p>function ptrarray2d{T&lt;:Real}(src::Array{T,2})</p>

<pre><code>dst = Array{Ptr{T}, size(src, 2))
for i=1:size(src, 2)
    dst[i] = pointer(src[:,i], 1) # 先頭要素のポインタを取り出す
end
dst
</code></pre>

<p>end
```</p>

<p>実はこの実装はバグを含んでいます。バグがあるとしたら一行しか該当する部分はないですが、</p>

<p><code>julia
dst[i] = pointer(src[:,i], 1)
</code></p>

<p>ここが間違っています。何が間違っているかというと、<code>pointer(src[:,i], 1)</code>は一見<code>src</code>の<code>i</code>列目の先頭要素のポインタを指しているような気がしますが、<code>src[:,1]</code>で <code>getindex</code>という関数が走って内部データのコピーを行っているので、そのコピーに対するポインタを指している（元データの<code>i</code>列目のポインタを指していない）点が間違っています<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。これは、JuliaのArray実装ついて多少知らないとわからないと思うので、ハマりどころと書きました。</p>

<p>Array <code>A</code>に対する syntax <code>X = A[I_1, I_2, ..., I_n]</code> は <code>X = getindex(A, I_1, I_2, ..., I_n)</code> と等価です。詳細は、<a href="http://docs.julialang.org/en/latest/manual/arrays/">Multi-dimensional Arrays</a>や<a href="http://docs.julialang.org/en/latest/stdlib/base/?highlight=getindex#Base.getindex">標準ライブラリのドキュメント</a> を参考にしてください</p>

<p>さて、正解を示します。</p>

<p>```julia</p>

<h1>Array{T,2} &ndash;> Array{Ptr{T}}</h1>

<p>function ptrarray2d{T&lt;:Real}(src::Array{T,2})</p>

<pre><code>dst = Array{Ptr{T}, size(src, 2))
for i=1:size(src, 2)
     dst[i] = pointer(sub(src, 1:size(src,1), i), 1)
end
dst
</code></pre>

<p>end
```</p>

<p>違いは <code>SubArray</code>を使うようになった点です。<code>SubArray</code>は、indexingを行うときにコピーを作らないので、期待した通りに<code>i</code>列目の先頭要素のポインタを取得することができます。<code>SubArray</code>について、以下引用しておきます<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>

<blockquote><p>SubArray is a specialization of AbstractArray that performs indexing by reference rather than by copying. A SubArray is created with the sub() function, which is called the same way as getindex() (with an array and a series of index arguments). The result of sub() looks the same as the result of getindex(), except the data is left in place. sub() stores the input index vectors in a SubArray object, which can later be used to index the original array indirectly.</p></blockquote>

<p>引用元: <a href="http://docs.julialang.org/en/latest/manual/arrays/#implementation">Multi-dimensional Arrays</a></p>

<h3>3. 変換した型をどのように元に戻すか</h3>

<p>Juliaで計算結果（上の例でいう <code>double** output</code>）を受け取りたい場合、ポインタに変換した値をJuliaのArrayに戻す必要があります（必ずしもそうではないですが、まぁほぼそうでしょう）。つまり、<code>Array(Ptr{Float64},1)</code>を<code>Array{Float64,2}</code>したいわけです。幸いにも、これは<code>pointer_to_array</code>を使うと簡単にできます。コードを以下に示します。</p>

<p>```julia</p>

<h1>ccallを実行した後の計算結果が coutput に格納されているとします</h1>

<p>coutput::Array{Ptr{Float64},1}</p>

<h1>Cに渡した型 Array{Ptr{Float64},1} から Array{Float64,2}に変換</h1>

<p>for i=1:length(coutput)</p>

<pre><code>output[:,i] = pointer_to_array(coutput[i], size(output, 1))
</code></pre>

<p>end
```</p>

<p><code>pointer_to_array</code> は、その名前の通りの関数ですね。pointerをArrayに変換してくれます。</p>

<h3>1, 2, 3 をまとめる</h3>

<p>最後に、1, 2, 3の内容をまとめて、ポインタのポインタを引数にもつ関数のラッパー例を書いておきます。</p>

<p>```julia
function fooo(input::Array{Float64,2})</p>

<pre><code>h, w = size(intput)
output = Array(Float64, h, w)

# C関数に渡す用の変数
cinput::Array{Ptr{Float64}} = ptrarray2d(input)
coutput::Array{Ptr{Float64}} = ptrarray2d(output)

ccall(:fooo, "libfooo", Void,
         (Ptr{Ptr{Float64}}, Int, Int, Ptr{Ptr{Float64}}), 
         cinput, w, h, coutput)

# coutputをJuliaのArrayに変換
for i=1:length(coutput)
    output[i,:] = pointer_to_array(coutput[i], h)
end

output
</code></pre>

<p>end
```</p>

<h3>ポインタのポインタまとめ</h3>

<ul>
<li><code>Array</code>のindexingはコピーを作るのである要素のポインタがほしい時は注意</li>
<li>行/列の先頭のポインタがほしいときは <code>SubArray</code> を使いましょう</li>
</ul>


<h2>おわりに</h2>

<p>ポインタにまつわるハマりどころとその解決法を紹介しました。今回紹介したものはすべて <a href="https://github.com/r9y9/WORLD.jl">WORLD.jl</a> という <a href="http://ml.cs.yamanashi.ac.jp/world/">音声分析変換合成システムWORLD</a> のラッパーを書いていたときに得た知見です。やっと<code>WORLD.jl</code>が安定して動くようになってきて公式パッケージにしようかなぁと考えているところですので、興味のある方はぜひ触ってみてください。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>immutableでなければいけない理由はまだよくわかっていないのですが、少なくとも <a href="https://github.com/JuliaLang/julia/pull/8948">#8948</a> にはそう書いてあります<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>たちの悪いことに、この実装でもだいたい上手く動くんですよね…。数値型がimmutableだからコピーしてもそうそうアドレスが変わらないとかそういう理由だろうかと考えていますが、ちょっとよくわかっていないです<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>ArrayとSubArrayの使い分けはどうすればいいのか、それぞれどういう目的で作られたのか等、僕も勉強中で理解が曖昧なため説明できません、すみません。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
