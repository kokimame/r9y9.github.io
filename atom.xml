<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LESS IS MORE]]></title>
  <link href="http://r9y9.github.io/atom.xml" rel="self"/>
  <link href="http://r9y9.github.io/"/>
  <updated>2015-12-23T01:12:48+09:00</updated>
  <id>http://r9y9.github.io/</id>
  <author>
    <name><![CDATA[Ryuichi YAMAMOTO]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cxx.jl を使ってみた感想 + OpenCV.jl, Libfreenect2.jl の紹介]]></title>
    <link href="http://r9y9.github.io/blog/2015/12/22/cxx-jl/"/>
    <updated>2015-12-22T00:23:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/12/22/cxx-jl</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://r9y9.github.io/images/opencvjl_demo.jpg" title="&#34;OpenCV.jl based on Cxx.jl&#34;" alt="&#34;OpenCV.jl based on Cxx.jl&#34;"></p>

<h2>はじめに</h2>

<p><a href="http://qiita.com/advent-calendar/2015/julialang">Julia Advent Calendar 2015</a> 22日目の記事です。</p>

<p>Julia の C++ FFI (Fourign Function Interface) である <a href="https://github.com/Keno/Cxx.jl">Cxx.jl</a> をしばらく使ってみたので、その感想を書きます。加えて、Cxx.jl を使って作った成果物の話も簡単に書こうと思います（冒頭に貼った画像は、OpenCV.jl でテキトーにカメラから画像をキャプチャしてthresholdingしたやつです）。
Cxx.jl の動作原理については、僕の理解が不十分なため簡単にしか紹介できませんが、そもそも使ったことがある人が稀だと思われるので、感想程度でも役に立てば幸いです。</p>

<h2>Cxx.jl とは</h2>

<p><a href="https://github.com/Keno/Cxx.jl">https://github.com/Keno/Cxx.jl</a></p>

<p>簡単に説明すると、Cxx.jl とは、Julia から C++ を使用する（e.g. 関数呼び出し、メソッド呼び出し、メンバ変数へのアクセス、etc) ための機能を提供するパッケージです。C++のライブラリを活用したい、あるいはパフォーマンスがシビアな箇所で一部 C++ 使いたい（Cインタフェースを作りたくない<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>）、といった場合に便利です。</p>

<p>Cxx.jl の原理についてざっくりといえば、clang を用いて C++ から LLVM IR を生成し、llvmcall を用いて（Just in time に）コードを実行する、という方式のようです<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Cxx.jl の原理について知りたい場合は、Cxx.jl のソースコード（+コメント）を、Cxx.jl を使うと何ができるのか知りたい場合は、Cxx.jl の README を御覧ください。</p>

<p>以下、過去を思い出しながら感想を書いてみます</p>

<h2>実際に使う前に</h2>

<h3>Pkg.build(&ldquo;Cxx&rdquo;) を成功させることが困難</h3>

<p>そもそも使いはじめる前に、ビルドすることが困難でした。Cxx.jl を動作させるためには、</p>

<ul>
<li>julia</li>
<li>llvm</li>
<li>clang</li>
<li>lldb</li>
</ul>


<p>の開発版が必要ですが、ビルドが難しい大きな原因は、動作することが保証された<strong>明確な revision が存在しない</strong>ことにあります。（なんじゃそれ、と思うかもしれませんが、まぁまだ安定版はリリースされていないので、、）</p>

<p>今でこそ、llvm, clang, lldbは、Keno氏の fork の kf/gallium ブランチ使えばいいよと README に書いてありますが、僕が使い始めた二ヶ月ほど前は、開発版のllvmが必要だよ、くらいにしか書いていませんでした（参考: <a href="https://github.com/Keno/Cxx.jl/blob/3897e8720b683fe35e407f2128d14e41cec8e0dd/README.md">Cxx.jl/README</a>）。何度もllvmをビルドし直すのは、本当に苦行でした…</p>

<p>参考：</p>

<blockquote class="twitter-tweet" lang="en"><p lang="ja" dir="ltr">今日だけでllvmをn回ビルドしてる（ビルドできたとは言ってない</p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/status/655000313112367104">October 16, 2015</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<br>


<p>思考停止の様子：</p>

<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">make -C deps clean-llvm &amp; make -j4</p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/status/670571501658251264">November 28, 2015</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<br>


<h3>Cxx.jl のビルドはどうするのが一番簡単なのか</h3>

<p>さて、さらっと書きましたが、今では llvm, clang, lldb　のkf/gallium　ブランチを使えば、比較的簡単に、多少の試行錯誤<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> で Cxx.jl をビルドして使えます。</p>

<h3>開発版 llvm と一緒に Julia をビルドする</h3>

<p>Juliaをクローンしたディレクトリで、以下の様な <code>Make.user</code> ファイルを作成して make します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override LLDB_VER=master
</span><span class='line'>override LLVM_VER=svn
</span><span class='line'>override LLVM_ASSERTIONS=1
</span><span class='line'>override BUILD_LLVM_CLANG=1
</span><span class='line'>override BUILD_LLDB=1
</span><span class='line'>override USE_LLVM_SHLIB=1
</span><span class='line'>override LLDB_DISABLE_PYTHON=1
</span><span class='line'>
</span><span class='line'>override LLVM_GIT_URL_LLVM=https://github.com/JuliaLang/llvm.git
</span><span class='line'>override LLVM_GIT_URL_LLDB=https://github.com/JuliaLang/lldb.git
</span><span class='line'>override LLVM_GIT_URL_CLANG=https://github.com/JuliaLang/clang.git
</span><span class='line'>override LLVM_GIT_VER=kf/gallium
</span><span class='line'>override LLVM_GIT_VER_LLDB=kf/gallium
</span><span class='line'>override LLVM_GIT_VER_CLANG=kf/gallium</span></code></pre></td></tr></table></div></figure>


<p>一部、LLVM_ASSERSONS を有効にするなど、必ずしも必須でないものも含まれていますが、こちらが現状の推奨のようです。この設定で、僕はubuntu 14.04, osx 10.10 でビルドが通ることを確認しました<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<p>注意：すでに llvm や clang がローカルにクローン済の場合、<code>deps/srccache</code> 以下からクローン済みのソースを消してからビルドすることをおすすめします。すでにクローンされていて、upstream  の変更を取り入れたい場合は、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>make -C deps update-llvm
</span></code></pre></td></tr></table></div></figure>


<p>とすると便利です。</p>

<h3>Cxx.jl のインストール</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="n">Pkg</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&quot;https://github.com/Keno/Cxx.jl.git&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">Pkg</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;Cxx&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>エラーがでなければ、インストール完了<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>です。</p>

<h2>実際に使ってみたあと</h2>

<p>さて、ようやくビルドもできて、ここからは使ってしばらくしての感想です。</p>

<h3>Julia 上で C++ の syntax がそのまま使える</h3>

<p>まず、簡単に Cxx.jl の機能を挙げると、重要なのは</p>

<ul>
<li><code>cxx"..."</code></li>
<li><code>icxx"..."</code></li>
<li><code>@cxx</code></li>
</ul>


<p>の三つです。以下、簡単に例をあげると、<code>cxx"..."</code> でC++ syntax を評価して：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">cxx</span><span class="s">&quot;#include &lt;iostream&gt;&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">cxx</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="k">namespace</span> <span class="n">test</span> <span class="p">{</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello C++&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="s">&quot;&quot;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>@cxx</code> マクロで C++ 関数を呼び出す：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="p">@</span><span class="n">cxx</span> <span class="n">test</span><span class="p">::</span><span class="n">f</span><span class="p">()</span>  <span class="c"># Hello C++</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>cxx"..."</code>はグローバルスコープで評価されますが、<code>icxx"..."</code> を使えば、特定のスコープ内で C++ を使用することもできます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="p">:</span><span class="mi">10</span>
</span><span class='line'>    <span class="n">icxx</span><span class="s">&quot;&quot;&quot;std::cout &lt;&lt; </span><span class="si">$</span><span class="s">i &lt;&lt; std::endl;&quot;&quot;&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ccall</code> のように、返り値、引数の型などを指定して実行するのではなく、C++ のsyntax をそのまま使ってコードが書ける、という点にびっくりしました。</p>

<h3>template も使える</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">cxx</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">T</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="s">&quot;&quot;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>こんな感じで特殊化も可能</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">cxx</span><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="s">&quot;&quot;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>書いてて気付きましたが、README には template について言及されていませんね。僕は、今のところ問題なく使えています。例には出していませんが、template class ももちろん使えます（例. <code>std::vector&lt;T&gt;</code>）。</p>

<h3>その他雑記</h3>

<ul>
<li>Cxx.jl で使える C++ には制約がある（はず）だが、ここ二ヶ月使用した限りでは、大きな制約に出会ってないし、快適</li>
<li>共有ライブラリの呼び出しは、<code>ccall</code> と違ってライブラリだけでなくヘッダーファイルも必要</li>
<li><code>using Cxx</code> にはけっこう時間がかかる。僕の環境では約15秒だった</li>
<li>たまに llvm error を吐いて落ちる。デバッグするには llvm, clang についてある程度知識がないと難しそう</li>
<li>C++ REPL 便利</li>
</ul>


<p>という感じですかね。書き進むに連れて適当になってすいません、、、</p>

<h2>Cxx.jl を使って作った成果物</h2>

<p>まとめに入る前に、Cxx.jl を使って遊ぶ過程で作った成果物を、簡単なコメント付きで紹介します。</p>

<h3>OpenCV.jl</h3>

<p><img class="center" src="http://r9y9.github.io/images/video_thresholding.gif" title="&#34;OpenCV.jl demo&#34;" alt="&#34;OpenCV.jl demo&#34;"></p>

<p><a href="https://github.com/r9y9/OpenCV.jl">https://github.com/r9y9/OpenCV.jl</a></p>

<p>Cxx.jl の学習の題材として作りました。途中から cv::Mat 周りを真面目に作り始めたので、それなりに使えると思います。</p>

<p>デザインポリシーとして、</p>

<ul>
<li>cv::Mat を <code>AbstractArray{T,N}</code> の subtype として Julia ライクに使えること</li>
<li>cv::Mat と Julia の Array の相互変換をサポートすること</li>
</ul>


<p>を念頭において作りました。</p>

<h3>LibFreenect2.jl</h3>

<p><img class="center" src="http://r9y9.github.io/images/depth_streaming_example.gif" title="&#34;LibFreenect2.jl demo&#34;" alt="&#34;LibFreenect2.jl demo&#34;"></p>

<p><a href="https://github.com/r9y9/LibFreenect2.jl">https://github.com/r9y9/LibFreenect2.jl</a></p>

<p>ちょうど仕事で kinect v2 を触っていたので、遊びがてらやってみました。</p>

<h2>まとめ</h2>

<ul>
<li>Cxx.jl をビルドするのはけっこう面倒ですが、C++を（主観ですが）ほとんど不自由なくJITライクに使えるので、非常に便利です</li>
<li>二つほど C++ ライブラリのラッパーを作ってみましたが、簡単にできるので、みなさんもお試しあれ</li>
<li>レッツ・トライ Cxx.jl！</li>
</ul>


<h2>おまけ</h2>

<p>現在 Julia community では、llvm 3.3 から llvm 3.7.1 に移行しようとする動きがあるので（ref: <a href="https://github.com/JuliaLang/julia/issues/9336">julia/issues/9336</a>, <a href="https://github.com/JuliaLang/julia/pull/14430">julia/pull/14430</a>）、移行後は、もう少しビルドが楽になるかもしれません。</p>

<p>実は、この記事を読んでも、きっと今は　Cxx.jl をビルドできないんじゃないかなと思うんですが、もしどうしてもビルドしたい、ということであれば、僕のローカルの llvm, clang, lldb, julia の revision を調べて教えるので、言ってください。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>例えば template を多用している場合、Cインタフェースを作るのは面倒です<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>※正確に理解していないため、あまり宛てにしないでください）<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>多少の試行錯誤、というのは、Julia と Cxx.jl のリビジョンは、経験的には必ずしも（特にJuliaの）masterで動作しないので、Julia と Cxx.jl を master から少し遡って、ビルドできるか試行錯誤する、という意味です<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>ビルドが通ったことがある、の方が正確ですが<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>なお、現状のJulia masterとCxx.jl masterでは、エラーが出ると踏んでおります、、、<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Julia: 値と変数に対する Type Annotation の違い]]></title>
    <link href="http://r9y9.github.io/blog/2015/12/08/julia-type-annotations/"/>
    <updated>2015-12-08T00:01:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/12/08/julia-type-annotations</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p><a href="http://qiita.com/advent-calendar/2015/julialang">Julia Advent Calendar 2015</a> 8日目の記事です。</p>

<p>この記事では、値 (value) と変数 (variable) に対する type annotation の違いを、問題とそれに対する解答を用意する形式で説明しようと思います。そんなの知ってるぜ！という方は、問題だけ解いてみて自分の理解度を試してもらえればと思います。</p>

<p>記事に出てくるJuliaコードは、Julia 0.5-dev, 0.4.0 で動作確認しました。</p>

<h2>問題</h2>

<p>新規REPLセッションを開いて、A、B それぞれを実行したときの挙動はどうなるでしょうか？エラーの発生の有無と、エラーが発生しない場合は返り値の値、型を答えてください。</p>

<h3>A</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="k">function</span><span class="nf"> f</span><span class="p">()</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)::</span><span class="kt">Int</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>B</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="k">function</span><span class="nf"> g</span><span class="p">()</span>
</span><span class='line'>    <span class="n">x</span><span class="p">::</span><span class="kt">Int</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>なお、一方ではエラーが起き、もう一方はエラー無く実行されます。一見似たような書き方ですが、二つは異なる意味を持ちます。この記事ではそれぞれを解説しようと思います。</p>

<p>この問題の答えがわからなかった方は、この記事を読むと正解がわかるはずなので、続きをご覧ください。下の方に、簡潔な問題の解答とおまけ問題を書いておきました。</p>

<h2>A: 値に対する type annotation</h2>

<p>Aの2行目では、値に対して type annotation をしています。これは typeassert とも呼びます。Aで使った type annotation を日本語で説明してみると、「<code>(1.0 + 2.0)</code> という式を評価した値は、Int 型であることを保証する」となります。</p>

<p><code>(1.0 + 2.0)</code> を評価した値は <code>3.0</code> であり、 Float64の型を持ちます。したがって <code>Float64 != Int</code> であるため、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="n">ERROR</span><span class="p">:</span> <span class="n">TypeError</span><span class="p">:</span> <span class="n">typeassert</span><span class="p">:</span> <span class="n">expected</span> <span class="kt">Int64</span><span class="p">,</span> <span class="n">got</span> <span class="kt">Float64</span>
</span></code></pre></td></tr></table></div></figure>


<p>のような typeassert のエラーが吐かれます。</p>

<p><code>(1.0 + 2.0)</code>を評価した値の型は一見して明らかため、実用的な例ではありませんが、例えば関数の返り値の型は一見してわからないことがあるので、例えば以下のような書き方は有用な場合もあると思います。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)::</span><span class="kt">Int</span>
</span></code></pre></td></tr></table></div></figure>


<h2>B: 変数に対する type annotation</h2>

<p>Bの2行目では、変数に対して type annotation をしています。同じく日本語で説明すると、「<code>x</code>という変数に入る値は、Int 型であることを保証する」となります。また、値に対する annotation とは異なり<strong>スコープ</strong>を持ちます。</p>

<p>前述したとおり、<code>(1.0 + 2.0)</code> を評価した値は <code>3.0</code> であり、Float64の型を持ちます。一方で、<code>x</code> は Int型の値を持つ変数として宣言されているため、この場合、Float64型である <code>(1.0 + 2.0)</code> を、Int 型に変換するような処理が<strong>暗黙的に</strong>行われます。したがって、変換可能な場合には（B の例がそうです）、エラーは起きません。暗黙的に処理が行われるというのは、知らないと予期せぬバグに遭遇することになるため、気をつける必要があります。</p>

<p>では、変数に対する type annotation はどのような場合に使うかというと、あるスコープの範囲で、代入によって変数の型が変わってしまうのを防ぐために使います。ある変数の型がスコープの範囲で不変というのはコンパイラにとっては嬉しい事で、パフォーマンスの向上に繋がります。Performance tips にもありますね（参考: <a href="http://docs.julialang.org/en/release-0.4/manual/performance-tips/#avoid-changing-the-type-of-a-variable">Performance tips / Avoid changing the type of a variable</a>）</p>

<h2>違いまとめ</h2>

<p>ここまでの話から、違いをまとめると、以下のようになります。</p>

<table>
<thead>
<tr>
<th> Type annotation の種類      </th>
<th> typeassert error　 </th>
<th> 暗黙的な型変換　 </th>
<th> スコープ　</th>
</tr>
</thead>
<tbody>
<tr>
<td> 値に対する type annotation   </td>
<td> あり             </td>
<td> なし           </td>
<td> なし</td>
</tr>
<tr>
<td> 変数に対する type annotation 　 </td>
<td> なし             </td>
<td> あり           </td>
<td> あり</td>
</tr>
</tbody>
</table>


<br>


<h2>最後に</h2>

<p>type annotation を使うときは、値と変数に対する annotation の違いを意識して、使い分けましょう</p>

<h2>問題の解答</h2>

<ul>
<li>A: typeassert に引っかかり、TypeError が吐かれる</li>
<li>B: Int 型の 3 が返り値として得られる</li>
</ul>


<h2>おまけ問題</h2>

<h3>1</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="k">function</span><span class="nf"> h</span><span class="p">()</span>
</span><span class='line'>    <span class="n">x</span><span class="p">::</span><span class="n">UInt8</span> <span class="o">=</span> <span class="n">UInt8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="c"># なんと表示されるでしょうか？</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="nb">typeof</span><span class="p">(</span><span class="n">h</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="k">function</span><span class="nf"> s</span><span class="p">()</span>
</span><span class='line'>    <span class="n">x</span><span class="p">::</span><span class="kt">Int</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="n">UInt8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="kt">Float32</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='jl'><span class='line'><span class="c"># なんと表示されるでしょうか？</span>
</span><span class='line'><span class="n">s</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>解答は、各自REPLで実行して確認してみてください。長々と読んでくださりありがとうございました。</p>

<h2>参考</h2>

<ul>
<li><a href="http://docs.julialang.org/en/release-0.4/manual/types/?highlight=typeassert#type-declarations">公式ドキュメント / Type Declarations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pysptk: SPTKのpythonラッパーを作った (part 2)]]></title>
    <link href="http://r9y9.github.io/blog/2015/09/06/pysptk/"/>
    <updated>2015-09-06T16:11:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/09/06/pysptk</id>
    <content type="html"><![CDATA[<p>2015/09/05:</p>

<div align="center">
<blockquote class="twitter-tweet" lang="en"><p lang="ja" dir="ltr"><a href="https://t.co/WFBmYEIVce">https://t.co/WFBmYEIVce</a> SPTKのpythonラッパー（マシなやつ）完成&#10;ドキュメント <a href="http://t.co/jYhw1y3Bzg">http://t.co/jYhw1y3Bzg</a>&#10;pip install pysptk でインストールできるようになりました。pypi童貞捨てれた</p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/status/639848868075560960">September 4, 2015</a></blockquote>
<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>


<p>ずいぶん前に、swig遊びをしがてらpythonのラッパーを書いていたんですが、cythonを使って新しく作りなおしました。かなりパワーアップしました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install pysptk</span></code></pre></td></tr></table></div></figure>


<p>でインストールできるので、よろしければどうぞ</p>

<h2>なぜ作ったのか</h2>

<ul>
<li>cythonとsphinxで遊んでたらできた</li>
</ul>


<h2>使い方</h2>

<p>以下のデモを参考にどうぞ</p>

<ul>
<li><a href="http://nbviewer.ipython.org/github/r9y9/pysptk/blob/51c103e5a7e9746c96cd78043df4e48fe2d6a3a8/examples/pysptk%20introduction.ipynb">Introduction to pysptk</a>: メル一般化ケプストラム分析とか</li>
<li><a href="http://nbviewer.ipython.org/github/r9y9/pysptk/blob/51c103e5a7e9746c96cd78043df4e48fe2d6a3a8/examples/Speech%20analysis%20and%20re-synthesis.ipynb">Speech analysis and re-synthesis</a>: 音声の分析・再合成のデモ。合成音声はnotebook上で再生できます</li>
</ul>


<h2>ドキュメント</h2>

<p><a href="http://pysptk.readthedocs.org">http://pysptk.readthedocs.org</a></p>

<h2>ぼやき</h2>

<p>SPTKの関数、変な値入れるとexitしたりセグフォったりするので、ちゃんとテスト書いてほしいなあ</p>

<h2>関連</h2>

<ul>
<li><a href="http://r9y9.github.io/blog/2014/08/10/sptk-from-python/">SPTKのPythonラッパーを書いた &ndash; LESS IS MORE</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近の音声信号処理遊びの進捗]]></title>
    <link href="http://r9y9.github.io/blog/2015/08/23/speech-analysis-and-synthesis-in-julia/"/>
    <updated>2015-08-23T16:35:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/08/23/speech-analysis-and-synthesis-in-julia</id>
    <content type="html"><![CDATA[<h2>hello</h2>

<p>遡ればもう約一年まえになるでしょうか、統計的声質遊びをしたいと思い、理論の勉強を始めたり、（特にJuliaで）コードを色々書いていました（お前ほんといろんな言語で遊んでるな、というツッコミはさておき）。<a href="http://r9y9.github.io/blog/2014/11/12/statistical-voice-conversion-code/">統計的声質変換クッソムズすぎワロタ（チュートリアル編） &ndash; LESS IS MORE</a> を書いていた当初は、当然自分のためだけに書いていて、まぁアレな出来でしたが、最近気を取り直して多少マシに仕上げましたので、何となくブログに書いてみようかなーと思った次第です。というわけで、最近公式に登録したいくつかのパッケージを、まとめて簡単に紹介します。</p>

<p>主な改善点は、windowsもちゃんとサポートするようにしたこと（誰得？）と、テストをきちんと書いたことと、julia的なインタフェースを意識するようにしたことですかね。3つ目はかなり曖昧ですが、まぁ気持ち使いやすくなったと思います。</p>

<h2>パッケージ</h2>

<ul>
<li><a href="https://github.com/r9y9/MelGeneralizedCepstrums.jl">MelGeneralizedCepstrums.jl</a>: メル一般化ケプストラム分析</li>
<li><a href="https://github.com/r9y9/SynthesisFilters.jl">SynthesisFilters.jl</a>: メル一般化ケプストラムからの音声波形合成</li>
<li><a href="https://github.com/r9y9/SPTK.jl">SPTK.jl</a>: <a href="http://sp-tk.sourceforge.net/">SPTK</a>のラッパー</li>
</ul>


<p>車輪の再発明はできるだけしたくなかったので、最初のほうはCライブラリのラッパーを書くことが多く、windowsとかめんどくさいしunix環境でしか動作確認してませんでしたが、<a href="http://qiita.com/r9y9/items/e0567e2a21a5e3c36e51">WindowsのJuliaから呼べるようなCライブラリの共有ライブラリ（DLL）を作る | qiita</a> 重い腰を上げてwindowsでも動くように頑張ったことがあり（めんどくさいとか言って手を動かさないのホント良くないですね）、登録したパッケージはすべてwindowsでも動くようになりました。めでたし。<a href="https://github.com/r9y9/WORLD.jl">WORLD.jl</a> もwindowsで動くようにしました。</p>

<h2>MelGeneralizedCepstrums.jl</h2>

<p>メルケプストラムの推定とか。いくつか例を載せておきます</p>

<p><img class="center" src="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/cepstrum.png" title="&#34;cepstrum based envelope.&#34;" alt="&#34;cepstrum based envelope.&#34;"></p>

<p><img class="center" src="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-cepstrum.png" title="&#34;mel-cepstrum based envelope.&#34;" alt="&#34;mel-cepstrum based envelope.&#34;"></p>

<p><img class="center" src="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/mel-generalized-cepstrum.png" title="&#34;mel-generalized-cepstrum based envelope.&#34;" alt="&#34;mel-generalized-cepstrum based envelope.&#34;"></p>

<p><img class="center" src="https://raw.githubusercontent.com/r9y9/MelGeneralizedCepstrums.jl/v0.0.1/examples/lpc-cepstrum.png" title="&#34;lpc-cepstrum based envelope.&#34;" alt="&#34;lpc-cepstrum based envelope.&#34;"></p>

<p>詳細はこちらの<a href="http://nbviewer.ipython.org/github/r9y9/MelGeneralizedCepstrums.jl/blob/v0.0.1/examples/Introduction%20to%20MelGeneralizedCeptrums.jl.ipynb">ノートブック</a>へ</p>

<p>メルケプストラム分析、メル一般化ケプストラム分析に関しては、SPTKの実装をjuliaで再実装してみました。結果、速度は1.0 ~ 1.5倍程度でおさまって、かつ数値的な安定性は増しています（メモリ使用量はお察し）。まぁ僕が頑張ったからというわけでなく、単にJuliaの線形方程式ソルバーがSPTKのものより安定しているというのが理由です。</p>

<h2>SynthesisFilters.jl</h2>

<p>メルケプストラムからの波形合成とか。</p>

<p>詳細はこちらの<a href="http://nbviewer.ipython.org/github/r9y9/SynthesisFilters.jl/blob/v0.0.1/examples/Introduction%20to%20SynthesisFilters.jl.ipynb">ノートブック</a>へ。いくつかの音声合成フィルタの合成音をノートブック上で比較することができます。</p>

<p><a href="http://nbviewer.ipython.org/github/r9y9/SynthesisFilters.jl/blob/mix-excitation/examples/Introduction%20to%20SynthesisFilters.jl.ipynb">mixed excitation（っぽいの）を使ったバージョンのノートブック</a>: 実装に自信がないので、そのうち消すかも。聴覚的にはこっちのほうが良いです。</p>

<h2>SPTK.jl</h2>

<p>公式のSPTKではなく、僕が少しいじったSPTK（windowsで動くようにしたり、APIとして使いやすいように関数内でexitしてた部分を適切なreturn code返すようにしたり、swipeというF0抽出のインタフェースをexposeしたり、など）をベースにしています。</p>

<p><a href="http://nbviewer.ipython.org/github/r9y9/SPTK.jl/blob/v0.0.1/examples/Introduction%20to%20SPTK.jl.ipynb">デモ用のノートブック</a></p>

<p>MelGeneralizedCepstrums.jl と SynthesiFilters.jl は、ほとんどSPTK.jlで成り立っています。本質的に SPTK.jl にできて MelGeneralizedCepstrums.jl と SynthesiFilters.jlにできないことは基本的にないのですが、後者の方が、より簡単な、Julia的なインタフェースになっています。</p>

<p>例えば、メルケプストラム、ケプストラム、LPCなど、スペクトルパラメータの型に応じて、適切なフィルタ係数に変換する、合成フィルタを選択するなど、multiple dispatchを有効に活用して、よりシンプルなインタフェースを提供するようにしました（というか自分がミスりたくなかったからそうしました）。</p>

<h2>おわり</h2>

<p>かなり適当に書きましたが、最近の進捗は、Juliaで書いていたパッケージ多少改善して、公式に登録したくらいでした。進捗まじ少なめ。あと些細なことですが、ipython（ijulia）に音埋め込むのクッソ簡単にできてびっくりしました（なんで今までやらなかったんだろう）。<a href="https://github.com/jfsantos">@jfsantos</a> に感謝</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JuliaTokyo #3 Speech Signal Processing in Julia]]></title>
    <link href="http://r9y9.github.io/blog/2015/04/26/juliatokyo3-speech-signal-processing-in-julia/"/>
    <updated>2015-04-26T23:29:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/04/26/juliatokyo3-speech-signal-processing-in-julia</id>
    <content type="html"><![CDATA[<p><a href="http://juliatokyo.connpass.com/event/13218/">JuliaTokyo #3</a>でLT発表してきました。前回の<a href="http://juliatokyo.connpass.com/event/8010/">JuliaTokyo #2</a>でも発表したので、二回目でした。</p>

<h2>スライド</h2>

<div align="center">
<iframe src="http://r9y9.github.io//www.slideshare.net/slideshow/embed_code/key/h4geMoK1msYqdY" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://r9y9.github.io//www.slideshare.net/ryuichiy/juliatokyo-3-speech-signal-processing-in-julia-47403938" title="JuliaTokyo #3 Speech Signal Processing in Julia" target="_blank">JuliaTokyo #3 Speech Signal Processing in Julia</a> </strong> from <strong><a href="http://r9y9.github.io//www.slideshare.net/ryuichiy" target="_blank">Ryuichi YAMAMOTO</a></strong> </div>
</div>


<h2>コード</h2>

<p><a href="https://github.com/r9y9/JuliaTokyo3">https://github.com/r9y9/JuliaTokyo3</a></p>

<h2>三行まとめ</h2>

<p>発表の内容を三行でまとめると、</p>

<ul>
<li>音声ファイルの読み込み（or 書き込み）は<a href="(https://github.com/dancasimiro/WAV.jl">WAV.jl</a>を使おう</li>
<li>基本的なデジタル信号処理は <a href="https://github.com/JuliaDSP/DSP.jl">JuliaDSP/DSP.jl</a> をチェック（※JuliaDSPにはウェーブレットとかもあるよ）</li>
<li>音声に特化した信号処理は、<a href="https://github.com/r9y9/WORLD.jl">r9y9/WORLD.jl</a> がオススメです</li>
</ul>


<p>という感じです。</p>

<p>応用例として、歌声を分離する話（<a href="https://github.com/r9y9/RobustPCA.jl">デモコード</a>）、統計的声質変換（<a href="http://r9y9.github.io/blog/2014/11/12/statistical-voice-conversion-code/">統計的声質変換クッソムズすぎワロタ（チュートリアル編） &ndash; LESS IS MORE</a>）、画像をスペクトログラムに足しこむ話とか、さっと紹介しました。</p>

<h2>補足</h2>

<p>僕が使う/作ったパッケージを、あとで見返せるように最後のスライドにまとめておいたのですが、改めてここで整理しておきます。</p>

<ul>
<li><a href="https://github.com/dancasimiro/WAV.jl">dancasimiro/WAV</a> WAVファイルの読み込み</li>
<li><a href="https://github.com/JuliaDSP/DSP.jl">JuliaDSP/DSP</a> 窓関数、スペクトログラム、デジタルフィルタ</li>
<li><a href="https://github.com/r9y9/WORLD.jl">r9y9/WORLD</a> 音声分析・合成フレームワーク</li>
<li><a href="https://github.com/r9y9/MelGeneralizedCepstrums.jl">r9y9/MelGeneralizedCepstrums</a> メル一般化ケプストラム分析</li>
<li><a href="https://github.com/r9y9/SynthesisFilters.jl">r9y9/SynthesisFilters</a> メル一般化ケプストラムからの波形合成</li>
<li><a href="https://github.com/r9y9/SPTK.jl">r9y9/SPTK</a> 音声信号処理ツールキット</li>
<li><a href="https://github.com/r9y9/RobustPCA.jl">r9y9/RobustPCA</a> ロバスト主成分分析(歌声分離へ応用)</li>
<li><a href="https://github.com/r9y9/REAPER.jl">r9y9/REAPER</a> 基本周波数推定</li>
<li><a href="https://github.com/r9y9/VoiceConversion.jl">r9y9/VoiceConversion</a> 統計的声質変換</li>
</ul>


<p>上から順に、<del>汎用的かなーと思います</del><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。僕が書いたパッケージの中では、<strong>WORLDのみ</strong>公式パッケージにしています。理由は単純で、その他のパッケージはあまりユーザがいないだろうなーと思ったからです。かなりマニアックであったり、今後の方針が決まってなかったり（ごめんなさい）、応用的過ぎて全然汎用的でなかったり。WORLDは自信を持ってオススメできますので、Juliaで音声信号処理をやってみようかなと思った方は、ぜひお試しください。</p>

<h2>ざっくり感想</h2>

<ul>
<li>＃Juliaわからん 本当に素晴らしいと思うので、僕も積極的に #Juliaわからん とつぶやいていこうと思います（詳しくは <a href="https://twitter.com/chezou">@chezou</a> さんの記事をどうぞ <a href="http://chezou.hatenablog.com/entry/2015/04/26/222518">#JuliaTokyo で #juliaわからん という雑なレポジトリを立てた話をしたら julia.tokyo ができてた  &ndash; once upon a time,</a>）。僕は、Julia に Theano が欲しいです。<code>T.grad</code> 強力すぎる</li>
<li><code>ccall</code> かんたんとか言いましたが、ミスった書き方をしたときのエラーメッセージはあまり親切ではないので、つまずきやすいかも。僕は気合で何とかしています。</li>
<li>Julia遅いんだけど？？？と言われたら、<a href="https://twitter.com/bicycle1885">@bicycle1885</a> さんの <a href="http://www.slideshare.net/KentaSato/whats-wrong-47403774">What&rsquo;s wrong with this Julia?</a> を投げつけようと思います。</li>
<li>かなり聴衆が限定的になってしまう話をしてしまったので、次発表するならJulia 言語自体の話をしようかなと思いました</li>
</ul>


<h2>最後に</h2>

<p><a href="https://twitter.com/sorami">@sorami</a>さんを筆頭とする運営の方々、本当にありがとうございました！楽しかったです。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>とスライドに書いたけど、考えなおすと、僕が思う品質の高さ順、の方が正確です、失礼しました。MelGeneneralizedCepstrumsは一番気合入れて書いたけど、ユーザーがいるかといったらいないし、RobustPCAはさっと書いただけだけど、アルゴリズムとしては汎用的だし。またRobustPCAだけ毛色が違いますが、応用例で紹介したのでリストに入れておきました。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ccallにおけるポインタ周りのハマりどころとその解決法]]></title>
    <link href="http://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips/"/>
    <updated>2014-12-09T02:20:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/advent-calendar/2014/julialang">Julia Advent Calendar 2014</a> 9日目の記事です。</p>

<h2>はじめに</h2>

<p>CやFortranの関数をJuliaから呼ぶために使用する<code>ccall</code>において、ポインタに関係するハマりどころとその解決法を紹介します。純粋なJuliaを使っている場合にはポインタを意識することはめったにないと思うので、<code>ccall</code> を使う人（計算が重いボトルネック部分をCで書いてJuliaから呼びたい人、Cのライブラリのラッパーを書きたい/書いてる人）を主な読者と想定して記事を書きました（限定的でごめんなさい）。</p>

<p>困った時は、公式ドキュメントの <a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a> を参考にしましょう。</p>

<p><strong>注意</strong>: 最新版の公式ドキュメントをいくつか引用していますが、ドキュメントは日々更新されていますので、この記事を読んで頂いた時点とは異なる可能性があることにご注意ください。</p>

<h2>こんなとき</h2>

<p><code>ccall</code> を使う際に、ポインタに関する以下のような疑問を持つことがあります。</p>

<ul>
<li>ポインタを引数に持つ（例. <code>double*</code>）関数のラッピングはどうすればいいのか？</li>
<li>構造体のポインタを引数に持つ関数のラッピングはどうすれば？</li>
<li>ポインタのポインタを引数に持つ（例. <code>double**</code>）関数のラッピングは？</li>
</ul>


<p>一つ目は非常に簡単で、<code>Array</code>（Cの関数が<code>double*</code>を取るならば<code>Array{Float64,1}</code>）をそのまま渡せばよいだけです。ドキュメントの<a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/#array-conversions">Array Conversions</a>にも書かれています。が、残りの二つに関してはハマりどころがあります。順に説明します。</p>

<h2>構造体のポインタを引数に持つ関数のラッピングはどうすれば？</h2>

<p>現状のドキュメントは少し不親切なので、引用した上で、整理します。</p>

<p><a href="http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a> より引用:</p>

<blockquote><p>Currently, it is not possible to pass structs and other non-primitive types from Julia to C libraries. However, C functions that generate and use opaque struct types by passing pointers to them can return such values to Julia as Ptr{Void}, which can then be passed to other C functions as Ptr{Void}. Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program.</p></blockquote>

<p>冒頭に it is not possible とあります。が、決して不可能なわけではありません。上記文章の要点をまとめると、</p>

<ul>
<li>opaqueな構造体はCからJuliaへポインタとして渡すことができる</li>
<li>そのポインタは <code>Ptr{Void}</code> としてCの関数に渡すことができる</li>
</ul>


<p>と書かれています。つまり、一般には構造体は渡せないけどポインタ渡しはできるよ、ということです。</p>

<p>じゃあnon-opaqueな構造体についてはどうなんだ？Juliaの型を渡せないのか？という疑問が出てきます。結論からいえば、non-opaqueな構造体についてもポインタ渡しは可能です。つまり、Cの構造体に相当するimmutableな型<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>をjuliaで宣言してあげれば、juliaの型をCに渡すことが可能です（値渡しはできません）</p>

<p>例を示します。</p>

<h3>Cコード</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>   <span class="kt">double</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 構造体のポインタを引数にとる関数1</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 構造体のポインタを引数にとる関数2</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Juliaコード</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># Cの構造体 Foo に相当する型を宣言します</span>
</span><span class='line'><span class="n">immutable</span> <span class="n">Foo</span>
</span><span class='line'>    <span class="n">a</span><span class="p">::</span><span class="kt">Float64</span>
</span><span class='line'>    <span class="n">b</span><span class="p">::</span><span class="kt">Int32</span> <span class="c"># cのintはjuliaのInt32に対応します</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Cの関数に、ポインタとしてJuliaの型を渡すことができます</span>
</span><span class='line'><span class="k">ccall</span><span class="p">(:</span><span class="n">print</span><span class="p">,</span> <span class="s">&quot;libfoo&quot;</span><span class="p">,</span> <span class="n">Void</span><span class="p">,</span> <span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Foo</span><span class="p">},),</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># ポインタで渡す場合、Cで変更した結果はJuliaにも反映されます</span>
</span><span class='line'><span class="k">ccall</span><span class="p">(:</span><span class="n">reset</span><span class="p">,</span> <span class="s">&quot;libfoo&quot;</span><span class="p">,</span> <span class="n">Void</span><span class="p">,</span> <span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Foo</span><span class="p">},),</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># foo(0.0, 0) と表示される</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>ちなみにJuliaからCへ値渡しをしてもエラーにならないので、お気をつけください（ハマりました）。</p>

<p>公式ドキュメントは不親切と言いましたが、 プルリクエスト <a href="https://github.com/JuliaLang/julia/pull/8948">update documentation for passing struct pointers to C #8948</a>（まだマージはされていない）で改善されているので、もしかするとこの記事が読まれる頃には改善されているかもしれません。</p>

<p>また、値渡しを可能にしようとする動きもあります（<a href="https://github.com/JuliaLang/julia/pull/3466">RFC: Make struct passing work properly #3466</a>, <a href="https://github.com/JuliaLang/julia/pull/2818">WIP: types as C-structs #2818</a> マージ待ち）。</p>

<h3>構造体渡しのまとめ</h3>

<ul>
<li>Cの構造体に相当するJuliaの型を定義して、ポインタで渡せばOK</li>
<li>値渡しは現状できない</li>
<li>ポインタを受けることはできる（Ptr{Void}として受ける）</li>
</ul>


<h2>ポインタのポインタを引数に持つ（例. <code>double**</code>）関数のラッピングは？</h2>

<p>さて、これはドキュメントにまったく書かれておらず、かつハマりやすいと僕は思っています。例を交えつつ解説します。以下のような関数のラッピングを考えます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">fooo</span><span class="p">(</span><span class="kt">double</span><span class="o">**</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">double</span><span class="o">**</span> <span class="n">output</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>input</code>は入力の行列、<code>output</code>は計算結果が格納される行列、行列のサイズは共に 列数<code>w</code>、行数<code>h</code> だと思ってください。Juliaからは <code>input::Array{Float64,2}</code> を入力として、<code>output::Array{Float64,2}</code> を得たいとします。</p>

<p><code>double*</code>を引数にとる場合は<code>Array{Float64,1}</code>を渡せばよかったのに対して、<code>double**</code>を引数に取る関数に <code>Array{Float64,2}</code>や<code>Array{Array{Float64,1},1}</code>を単純に渡すだけでは、残念ながらコンパイルエラーになります。はい、すでに若干面倒ですね。。さて、どうすればいいかですが、</p>

<ul>
<li>どんな型で渡せばいいか</li>
<li>どのように型を変換するか</li>
<li>変換した型をどのように元に戻すか</li>
</ul>


<p>という三点に分けて説明します。</p>

<h3>1. どんな型で渡せばいいか</h3>

<p><code>Array{Ptr{Float64}}</code> で渡せばよいです。外側のArrayは、<code>ccall</code> がポインタに変換してくれるので、Juliaの型でいえば<code>Ptr{Ptr{Float64}}</code>、Cの型で言えば<code>double**</code>になるわけです。</p>

<h3>2. どのように型を変換するか</h3>

<p>ここがハマりどころです。今回の例では、<code>Array{Float64,2}</code> を <code>Array{Ptr{Float64},1}</code> に変換すればよいので、例えば以下のような実装が思いつきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># Array{T,2} -&gt; Array{Ptr{T}}</span>
</span><span class='line'><span class="k">function</span><span class="nf"> ptrarray2d</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span class="n">src</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">})</span>
</span><span class='line'>    <span class="n">dst</span> <span class="o">=</span> <span class="n">Array</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="n">size</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">src</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># 先頭要素のポインタを取り出す</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">dst</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>実はこの実装はバグを含んでいます。バグがあるとしたら一行しか該当する部分はないですが、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">src</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>ここが間違っています。何が間違っているかというと、<code>pointer(src[:,i], 1)</code>は一見<code>src</code>の<code>i</code>列目の先頭要素のポインタを指しているような気がしますが、<code>src[:,1]</code>で <code>getindex</code>という関数が走って内部データのコピーを行っているので、そのコピーに対するポインタを指している（元データの<code>i</code>列目のポインタを指していない）点が間違っています<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。これは、JuliaのArray実装ついて多少知らないとわからないと思うので、ハマりどころと書きました。</p>

<p>Array <code>A</code>に対する syntax <code>X = A[I_1, I_2, ..., I_n]</code> は <code>X = getindex(A, I_1, I_2, ..., I_n)</code> と等価です。詳細は、<a href="http://docs.julialang.org/en/latest/manual/arrays/">Multi-dimensional Arrays</a>や<a href="http://docs.julialang.org/en/latest/stdlib/base/?highlight=getindex#Base.getindex">標準ライブラリのドキュメント</a> を参考にしてください</p>

<p>さて、正解を示します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># Array{T,2} -&gt; Array{Ptr{T}}</span>
</span><span class='line'><span class="k">function</span><span class="nf"> ptrarray2d</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span class="n">src</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">})</span>
</span><span class='line'>    <span class="n">dst</span> <span class="o">=</span> <span class="n">Array</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="n">size</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>         <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">dst</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>違いは <code>SubArray</code>を使うようになった点です。<code>SubArray</code>は、indexingを行うときにコピーを作らないので、期待した通りに<code>i</code>列目の先頭要素のポインタを取得することができます。<code>SubArray</code>について、以下引用しておきます<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>

<blockquote><p>SubArray is a specialization of AbstractArray that performs indexing by reference rather than by copying. A SubArray is created with the sub() function, which is called the same way as getindex() (with an array and a series of index arguments). The result of sub() looks the same as the result of getindex(), except the data is left in place. sub() stores the input index vectors in a SubArray object, which can later be used to index the original array indirectly.</p></blockquote>

<p>引用元: <a href="http://docs.julialang.org/en/latest/manual/arrays/#implementation">Multi-dimensional Arrays</a></p>

<h3>3. 変換した型をどのように元に戻すか</h3>

<p>Juliaで計算結果（上の例でいう <code>double** output</code>）を受け取りたい場合、ポインタに変換した値をJuliaのArrayに戻す必要があります（必ずしもそうではないですが、まぁほぼそうでしょう）。つまり、<code>Array(Ptr{Float64},1)</code>を<code>Array{Float64,2}</code>したいわけです。幸いにも、これは<code>pointer_to_array</code>を使うと簡単にできます。コードを以下に示します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># ccallを実行した後の計算結果が coutput に格納されているとします</span>
</span><span class='line'><span class="n">coutput</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span><span class="mi">1</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Cに渡した型 Array{Ptr{Float64},1} から Array{Float64,2}に変換</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">coutput</span><span class="p">)</span>
</span><span class='line'>    <span class="n">output</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointer_to_array</span><span class="p">(</span><span class="n">coutput</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>pointer_to_array</code> は、その名前の通りの関数ですね。pointerをArrayに変換してくれます。</p>

<h3>1, 2, 3 をまとめる</h3>

<p>最後に、1, 2, 3の内容をまとめて、ポインタのポインタを引数にもつ関数のラッパー例を書いておきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="k">function</span><span class="nf"> fooo</span><span class="p">(</span><span class="n">input</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">})</span>
</span><span class='line'>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">intput</span><span class="p">)</span>
</span><span class='line'>    <span class="n">output</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># C関数に渡す用の変数</span>
</span><span class='line'>    <span class="n">cinput</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}</span> <span class="o">=</span> <span class="n">ptrarray2d</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
</span><span class='line'>    <span class="n">coutput</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}</span> <span class="o">=</span> <span class="n">ptrarray2d</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">ccall</span><span class="p">(:</span><span class="n">fooo</span><span class="p">,</span> <span class="s">&quot;libfooo&quot;</span><span class="p">,</span> <span class="n">Void</span><span class="p">,</span>
</span><span class='line'>           <span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}},</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">Ptr</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}),</span>
</span><span class='line'>           <span class="n">cinput</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">coutput</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># coutputをJuliaのArrayに変換</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">coutput</span><span class="p">)</span>
</span><span class='line'>        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pointer_to_array</span><span class="p">(</span><span class="n">coutput</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">output</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ポインタのポインタまとめ</h3>

<ul>
<li><code>Array</code>のindexingはコピーを作るのである要素のポインタがほしい時は注意</li>
<li>行/列の先頭のポインタがほしいときは <code>SubArray</code> を使いましょう</li>
</ul>


<h2>おわりに</h2>

<p>ポインタにまつわるハマりどころとその解決法を紹介しました。今回紹介したものはすべて <a href="https://github.com/r9y9/WORLD.jl">WORLD.jl</a> という <a href="http://ml.cs.yamanashi.ac.jp/world/">音声分析変換合成システムWORLD</a> のラッパーを書いていたときに得た知見です。やっと<code>WORLD.jl</code>が安定して動くようになってきて公式パッケージにしようかなぁと考えているところですので、興味のある方はぜひ触ってみてください。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>immutableでなければいけない理由はまだよくわかっていないのですが、少なくとも <a href="https://github.com/JuliaLang/julia/pull/8948">#8948</a> にはそう書いてあります<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>たちの悪いことに、この実装でもだいたい上手く動くんですよね…。数値型がimmutableだからコピーしてもそうそうアドレスが変わらないとかそういう理由だろうかと考えていますが、ちょっとよくわかっていないです<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>ArrayとSubArrayの使い分けはどうすればいいのか、それぞれどういう目的で作られたのか等、僕も勉強中で理解が曖昧なため説明できません、すみません。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[統計的声質変換クッソムズすぎワロタ（チュートリアル編）]]></title>
    <link href="http://r9y9.github.io/blog/2014/11/12/statistical-voice-conversion-code/"/>
    <updated>2014-11-12T01:30:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/11/12/statistical-voice-conversion-code</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p>こんばんは。統計的声質変換（以降、簡単に声質変換と書きます）って面白いなーと思っているのですが、興味を持つ人が増えたらいいなと思い、今回は簡単なチュートリアルを書いてみます。間違っている箇所があれば、指摘してもらえると助かります。よろしくどうぞ。</p>

<p>前回の記事（<a href="http://r9y9.github.io/blog/2014/07/13/statistical-voice-conversion-wakaran/">統計的声質変換クッソムズすぎワロタ（実装の話） &ndash; LESS IS MORE</a>）では変換部分のコードのみを貼りましたが、今回はすべてのコードを公開します。なので、記事内で示す声質変換の結果を、この記事を読んでいる方が再現することも可能です。対象読者は、特に初学者の方で、声質変換を始めたいけれど論文からコードに落とすにはハードルが高いし、コードを動かしながら仕組みを理解していきたい、という方を想定しています。役に立てば幸いです。</p>

<h2>コード</h2>

<p><a href="https://github.com/r9y9/VoiceConversion.jl">https://github.com/r9y9/VoiceConversion.jl</a></p>

<p><a href="http://julialang.org">Julia</a> という言語で書かれています。Juliaがどんな言語かをさっと知るのには、以下のスライドがお勧めです。人それぞれ好きな言語で書けばいいと思いますが、個人的にJuliaで書くことになった経緯は、最後の方に簡単にまとめました。</p>

<div align="center"><iframe src="http://r9y9.github.io//www.slideshare.net/slideshow/embed_code/39141184" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://r9y9.github.io//www.slideshare.net/kentaroiizuka/julia-39141184" title="プログラミング言語 Julia の紹介" target="_blank">プログラミング言語 Julia の紹介</a> </strong> from <strong><a href="http://r9y9.github.io//www.slideshare.net/kentaroiizuka" target="_blank">Kentaro Iizuka</a></strong> </div></div>


<h2>サードパーティライブラリ</h2>

<p>声質変換は多くのコンポーネントによって成り立っていますが、すべてを自分で書くのは現実的ではありません。僕は、主に以下のライブラリを活用しています。</p>

<ul>
<li><a href="http://ml.cs.yamanashi.ac.jp/world/">WORLD</a> &ndash; 音声分析合成のフレームワークとして、あるいは単にスペクトル包絡を抽出するツールとして使っています。<a href="https://github.com/r9y9/WORLD.jl">Juliaラッパー</a>を書きました。</li>
<li><a href="sp-tk.sourceforge.net">SPTK</a> &ndash; メル対数スペクトル近似（Mel-Log Spectrum Approximation; MLSA）フィルタを変換処理に使っています。これも<a href="https://github.com/r9y9/SPTK.jl">Juliaラッパー</a>を書きました。</li>
<li><a href="http://scikit-learn.org/stable/">sklearn</a> &ndash; sklearn.mixture をGMMの学習に使っています。pythonのライブラリは、juliaから簡単に呼べます。</li>
</ul>


<p>音声分析合成に関しては、アカデミック界隈ではよく使われている<a href="http://www.wakayama-u.ac.jp/~kawahara/STRAIGHTadv/index_j.html">STRAIGHT</a>がありますが、WORLDの方がライセンスもゆるくソースも公開されていて、かつ性能も劣らない（正確な話は、森勢先生の論文を参照してください）ので、おすすめです。</p>

<h2><a href="https://github.com/r9y9/VoiceConversion.jl">VoiceConversion.jl</a> でできること</h2>

<h3>追記 2015/01/07</h3>

<p>この記事を書いた段階のv0.0.1は、依存ライブラリの変更のため、現在は動きません。すみません。何のためのタグだ、という気がしてきますが、、最低限masterは動作するようにしますので、そちらをお試しください（基本的には、新しいコードの方が改善されています）。それでも動かないときは、issueを投げてください。</p>

<p>2014/11/10現在（v0.0.1のタグを付けました）、できることは以下の通りです（外部ライブラリを叩いているものを含む）。</p>

<ul>
<li>音声波形からのメルケプストラムの抽出</li>
<li>DPマッチングによるパラレルデータの作成</li>
<li>GMMの学習</li>
<li>GMMベースのframe-by-frame特徴量変換</li>
<li>GMMベースのtrajectory特徴量変換</li>
<li>GMMベースのtrajectory特徴量変換（GV考慮版）</li>
<li>音声分析合成系WORLDを使った声質変換</li>
<li>MLSAフィルタを使った差分スペクトルに基づく声質変換</li>
</ul>


<p>これらのうち、trajectory変換以外を紹介します。</p>

<h2>チュートリアル：CMU_ARCTICを使ったGMMベースの声質変換（特徴抽出からパラレルデータの作成、GMMの学習、変換・合成処理まで）</h2>

<p>データセットに<a href="http://festvox.org/cmu_arctic/">CMU_ARCTIC</a>を使って、GMMベースの声質変換（clb &ndash;> slt）を行う方法を説明します。なお、VoiceConversion.jl のv0.0.1を使います。ubuntuで主に動作確認をしていますが、macでも動くと思います。</p>

<h2>0. 前準備</h2>

<h3>0.1. データセットのダウンロード</h3>

<p><a href="http://festvox.org/cmu_arctic/">Festvox: CMU_ARCTIC Databases</a> を使います。コマンド一発ですべてダウンロードする<a href="https://gist.github.com/r9y9/ff67c05aeb87410eae2e">スクリプト</a>を書いたので、ご自由にどうぞ。</p>

<h3>0.2. juliaのインストール</h3>

<p><a href="http://julialang.org/">公式サイト</a>からバイナリをダウンロードするか、<a href="https://github.com/JuliaLang/julia">githubのリポジトリ</a>をクローンしてビルドしてください。バージョンは、現在の最新安定版のv0.3.2を使います。</p>

<p>記事内では、juliaの基本的な使い方については解説しないので、前もってある程度調べておいてもらえると、スムーズに読み進められるかと思います。</p>

<h3>0.3. VoiceConversion.jl のインストール</h3>

<p>juliaを起動して、以下のコマンドを実行してください。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pkg</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&quot;https://github.com/r9y9/VoiceConversion.jl&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pkg</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;VoiceConversion&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>サードパーティライブラリは、sklearnを除いてすべて自動でインストールされます。sklearnは、例えば以下のようにしてインストールしておいてください。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo pip install sklearn
</span></code></pre></td></tr></table></div></figure>


<p>これで準備は完了です！</p>

<h2>1. 音声波形からのメルケプストラムの抽出</h2>

<p>まずは、音声から声質変換に用いる特徴量を抽出します。特徴量としては、声質変換や音声合成の分野で広く使われているメルケプストラムを使います。メルケプストラムの抽出は、<code>scripts/mcep.jl</code> を使うことでできます。</p>

<h3>2014/11/15 追記</h3>

<p>実行前に、<code>julia&gt; Pkg.add("WAV")</code> として、WAVパッケージをインストールしておいてください。(2014/11/15時点のmasterでは自動でインストールされますが、v0.0.1ではインストールされません、すいません）。また、メルケプストラムの出力先ディレクトリは事前に作成しておいてください（最新のスクリプトでは自動で作成されます）。</p>

<p>以下のようにして、2話者分の特徴量を抽出しましょう。以下のスクリプトでは、 <code>~/data/cmu_arctic/</code> にデータがあることを前提としています。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># clb</span>
</span><span class='line'>julia mcep.jl ~/data/cmu_arctic/cmu_us_clb_arctic/wav/ ~/data/cmu_arctic_jld/speakers/clb/
</span><span class='line'><span class="c"># slt</span>
</span><span class='line'>julia mcep.jl ~/data/cmu_arctic/cmu_us_slt_arctic/wav/ ~/data/cmu_arctic_jld/speakers/slt/
</span></code></pre></td></tr></table></div></figure>


<p>基本的な使い方は、<code>mcep.jl &lt;wavファイルがあるディレクトリ&gt; &lt;メルケプストラムが出力されるディレクトリ&gt;</code> になっています。オプションについては、 <code>mcep.jl -h</code> としてヘルプを見るか、コードを直接見てください。</p>

<p>抽出されたメルケプストラムは、HDF5フォーマットで保存されます。メルケプストラムの中身を見てみると、以下のような感じです。可視化には、PyPlotパッケージが必要です。Juliaを開いて、<code>julia&gt; Pkg.add("PyPlot")</code> とすればOKです。IJuliaを使いたい場合（僕は使っています）は、<code>julia&gt; Pkg.add("IJulia")</code> としてIJuliaもインストールしておきましょう。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># メルケプストラムの可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">using</span> <span class="n">HDF5</span><span class="p">,</span> <span class="n">JLD</span><span class="p">,</span> <span class="n">PyPlot</span>
</span><span class='line'>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s">&quot;clb/arctic_a0028.jld&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">colorbar</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_a0028_melcepstrum.png" title="&#34;Mel-cepstrum of clb_a0028.&#34;" alt="&#34;Mel-cepstrum of clb_a0028.&#34;"></p>

<p>0次成分だけ取り出してみると、以下のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># メルケプストラムの0次成分のみを可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;0th order mel-cesptrum of clb_a0028&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="c"># 末尾がsilenceだった都合上…（決め打ち）</span>
</span><span class='line'><span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;Frame&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&quot;upper right&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c"># 見やすいように適当に決めました</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_a0028_melcepstrum_0th.png" title="&#34;Mel-cepstrum of clb_a0028 0th.&#34;" alt="&#34;Mel-cepstrum of clb_a0028 0th.&#34;"></p>

<p>こんな感じです。話者clbの<code>clb_a0028.wav</code>を聞きながら、特徴量見てみてください。0次の成分からは、音量の大小が読み取れると思います。</p>

<h2>2. DPマッチングによるパラレルデータの作成</h2>

<p>次に、2話者分の特徴量を時間同期して連結します。基本的に声質変換では、音韻の違いによらない特徴量（非言語情報）の対応関係を学習するために、同一発話内容の特徴量を時間同期し（音韻の違いによる変動を可能な限りなくすため）、学習データとして用います。このデータのことを、パラレルデータと呼びます。</p>

<p>パラレルデータの作成には、DPマッチングを使うのが一般的です。<code>scripts/align.jl</code> を使うとできます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>julia align.jl ~/data/cmu_arctic_jld/speakers/clb ~/data/cmu_arctic_jld/speakers/slt ~/data/cmu_arctic_jld/parallel/clb_and_slt/
</span></code></pre></td></tr></table></div></figure>


<p>使い方は、<code>align.jl &lt;話者1（clb）の特徴量のパス&gt; &lt;話者2（slt）の特徴量のパス&gt; &lt;パラレルデータの出力先&gt;</code> になっています。</p>

<p>きちんと時間同期されているかどうか、0次成分を見て確認してみましょう。</p>

<p>時間同期を取る前のメルケプストラムを以下に示します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># 時間同期前のメルケプストラム（0次）を可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s">&quot;clb/arctic_a0028.jld&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">y</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s">&quot;slt/arctic_a0028.jld&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;0th order mel-cesptrum of clb_a0028&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;0th order mel-cesptrum of slt_a0028&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="c"># 決め打ち</span>
</span><span class='line'><span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;Frame&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&quot;upper right&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c"># 決め打ち</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_and_slt_a0028_melcepstrum_0th.png" title="&#34;0th order mel-cepstrum (not aligned)&#34;" alt="&#34;0th order mel-cepstrum (not aligned)&#34;"></p>

<p>ちょっとずれてますね</p>

<p>次に、時間同期後のメルケプストラムを示します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># 時間同期後のメルケプストラム（0次）を可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">parallel</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s">&quot;arctic_a0028_parallel.jld&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">parallel</span><span class="p">[</span><span class="s">&quot;src&quot;</span><span class="p">][</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;0th order mel-cesptrum of clb_a0028&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">plot</span><span class="p">(</span><span class="n">vec</span><span class="p">(</span><span class="n">parallel</span><span class="p">[</span><span class="s">&quot;tgt&quot;</span><span class="p">][</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;0th order mel-cesptrum of slt_a0028&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">parallel</span><span class="p">[</span><span class="s">&quot;tgt&quot;</span><span class="p">][</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'><span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;Frame&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">legend</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_and_slt_a0028_melcepstrum_0th_aligned.png" title="&#34;0th order mel-cepstrum (aligned)&#34;" alt="&#34;0th order mel-cepstrum (aligned)&#34;"></p>

<p>ずれが修正されているのがわかりますね。注意として、<code>align.jl</code> の中身を追えばわかるのですが、無音区間をしきい値判定で検出して、パラレルデータから除外しています。</p>

<p>結果、時間同期されたパラレルデータは以下のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># パラレルデータの可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">imshow</span><span class="p">(</span><span class="n">vcat</span><span class="p">(</span><span class="n">parallel</span><span class="p">[</span><span class="s">&quot;src&quot;</span><span class="p">][</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">],</span> <span class="n">parallel</span><span class="p">[</span><span class="s">&quot;tgt&quot;</span><span class="p">][</span><span class="s">&quot;feature_matrix&quot;</span><span class="p">]),</span> <span class="n">origin</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">colorbar</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_and_slt_a0028_parallel.png" title="&#34;example of parallel data&#34;" alt="&#34;example of parallel data&#34;"></p>

<p>このパラレルデータを（複数の発話分さらに結合して）使って、特徴量の対応関係を学習していきます。モデルには、GMMを使います。</p>

<h2>3. GMMの学習</h2>

<p>GMMの学習には、<code>sklearn.mixture.GMM</code> を使います。GMMは古典的な生成モデルで、実装は探せばたくさん見つかるので、既存の有用なライブラリを使えば十分です。（余談ですが、pythonのライブラリを簡単に呼べるのはjuliaの良いところの一つですね）</p>

<p><code>scripts/train_gmm.jl</code> を使うと、モデルのダンプ、julia &lt;&ndash;> python間のデータフォーマットの変換等、もろもろやってくれます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>julia train_gmm.jl ~/data/cmu_arctic_jld/parallel/clb_and_slt/ clb_and_slt_gmm32_order40.jld --max 200 --n_components 32 --n_iter<span class="o">=</span>100 --n_init<span class="o">=</span>1
</span></code></pre></td></tr></table></div></figure>


<p>使い方は、<code>train_gmm.jl &lt;パラレルデータのパス&gt; &lt;出力するモデルデータのパス&gt;</code> になっています。上の例では、学習に用いる発話数、GMMの混合数、反復回数等を指定しています。オプションの詳細はスクリプトをご覧ください。</p>

<p>僕の環境では、上記のコマンドを叩くと2時間くらいかかりました。学習が終わったところで、学習済みのモデルのパラメータを可視化してみましょう。</p>

<p>まずは平均を見てみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># GMMの平均ベクトルを（いくつか）可視化</span>
</span><span class='line'><span class="n">gmm</span> <span class="o">=</span> <span class="nb">load</span><span class="p">(</span><span class="s">&quot;clb_and_slt_gmm32_order40.jld&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span>
</span><span class='line'>    <span class="n">plot</span><span class="p">(</span><span class="n">gmm</span><span class="p">[</span><span class="s">&quot;means&quot;</span><span class="p">][:,</span><span class="n">k</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;mean of mixture </span><span class="si">$</span><span class="s">k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">legend</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_and_slt_gmm32_order40_mean.png" title="&#34;means of trained GMM&#34;" alt="&#34;means of trained GMM&#34;"></p>

<p>共分散の一部可視化してみると、以下のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="c"># GMMの共分散行列を一部可視化</span>
</span><span class='line'>
</span><span class='line'><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">imshow</span><span class="p">(</span><span class="n">gmm</span><span class="p">[</span><span class="s">&quot;covars&quot;</span><span class="p">][:,:,</span><span class="mi">2</span><span class="p">])</span>
</span><span class='line'><span class="n">colorbar</span><span class="p">()</span>
</span><span class='line'><span class="n">clim</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.16</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://r9y9.github.io/images/clb_and_slt_gmm32_order40_covar.png" title="&#34;covariance of trained GMM&#34;" alt="&#34;covariance of trained GMM&#34;"></p>

<p>まぁこんなもんですね。</p>

<h2>4. 音声分析合成WORLDを用いたGMMベースのframe-by-frame声質変換</h2>

<p>さて、ようやく声質変換の準備が整いました。学習したモデルを使って、GMMベースのframe-by-frame声質変換（clb &ndash;> slt ）をやってみましょう。具体的な変換アルゴリズムは、論文（例えば<a href="http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf">戸田先生のこれ</a>）をチェックしてみてください。音声分析合成系にはWORLDを使います。</p>

<p>一般的な声質変換では、まず音声を以下の三つの成分に分解します。</p>

<ul>
<li>基本周波数</li>
<li>スペクトル包絡（今回いじりたい部分）</li>
<li>非周期性成分</li>
</ul>


<p>その後、スペクトル包絡に対して変換を行い、変換後のパラメータを使って音声波形を合成するといったプロセスを取ります。これらは、<code>scripts/vc.jl</code> を使うと簡単にできるようになっています。本当にWORLDさまさまです。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>julia vc.jl ~/data/cmu_arctic/cmu_us_clb_arctic/wav/arctic_a0028.wav clb_and_slt_gmm32_order40.jld clb_to_slt_a0028.wav --order 40
</span></code></pre></td></tr></table></div></figure>


<p>使い方は、<code>vc.jl &lt;変換対象の音声ファイル&gt; &lt;変換モデル&gt; &lt;出力wavファイル名&gt;</code> となっています。</p>

<p>上記のコマンドを実行すると、GMMベースのframe-by-frame声質変換の結果が音声ファイルに出力されます。以下に結果を貼っておくので、聞いてみてください。</p>

<h3>変換元となる音声 clb_a0028</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/176093202&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<h3>変換目標となる話者 slt_a0028</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/176093240&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<h3>変換結果 clb_to_slt_a0028</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/176093403&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>話者性はなんとなく目標話者に近づいている気がしますが、音質が若干残念な感じですね。。</p>

<h2>5. 差分スペクトル補正に基づく声質変換</h2>

<p>最後に、より高品質な声質変換を達成可能な差分スペクトル補正に基づく声質変換を紹介します。差分スペクトル補正に基づく声質変換では、基本周波数や非周期性成分をいじれない代わりに音質はかなり改善します。以前書いた記事（<a href="http://r9y9.github.io/blog/2014/07/05/statistical-voice-conversion-muzui/">統計的声質変換クッソムズすぎワロタ &ndash; LESS IS MORE</a>）から、着想に関連する部分を引用します。</p>

<blockquote><p>これまでは、音声を基本周波数、非周期性成分、スペクトル包絡に分解して、スペクトル包絡を表す特徴量を変換し、変換後の特徴量を元に波形を再合成していました。ただ、よくよく考えると、そもそも基本周波数、非周期性成分をいじる必要がない場合であれば、わざわざ分解して再合成する必要なくね？声質の部分のみ変換するようなフィルタかけてやればよくね？という考えが生まれます。実は、そういったアイデアに基づく素晴らしい手法があります。それが、差分スペクトル補正に基づく声質変換です。</p></blockquote>

<p>差分スペクトル補正に基づく声質変換の詳細ついては、最近inter speechに論文が出たようなので、そちらをご覧ください。</p>

<ul>
<li><a href="http://isw3.naist.jp/~kazuhiro-k/resource/kobayashi14IS.pdf">[Kobayashi 2014] Kobayashi, Kazuhiro, et al. &ldquo;Statistical Singing Voice Conversion with Direct Waveform Modification based on the Spectrum Differential.&rdquo; Fifteenth Annual Conference of the International Speech Communication Association. 2014.</a></li>
</ul>


<p>こばくん、論文を宣伝しておきますね＾＾</p>

<h3>5.1 差分特徴量の学習</h3>

<p>さて、差分スペクトル補正に基づく声質変換行うには、変換元話者$X$と目標話者$Y$の特徴量の同時分布$P(X,Y)$を学習するのではなく、$P(X, Y-X)$ （日本語で書くとややこしいのですが、変換元話者の特徴量$X$と、変換元話者と目標話者の差分特徴量$Y-X$の同時分布）を学習します。これは、 <code>train_gmm.jl</code> を使ってGMMを学習する際に、<code>--diff</code> とオプションをつけるだけでできます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>julia train_gmm.jl ~/data/cmu_arctic_jld/parallel/clb_and_slt/ clb_to_slt_gmm32_order40_diff.jld --max 200 --n_components 32 --n_iter<span class="o">=</span>100 --n_init<span class="o">=</span>1 --diff
</span></code></pre></td></tr></table></div></figure>


<p>可視化してみます。</p>

<p>平均</p>

<p><img class="center" src="http://r9y9.github.io/images/clb_to_slt_gmm32_order40_mean.png" title="&#34;means of trained DIFFGMM&#34;" alt="&#34;means of trained DIFFGMM&#34;"></p>

<p>共分散</p>

<p><img class="center" src="http://r9y9.github.io/images/clb_to_slt_gmm32_order40_covar.png" title="&#34;covar of trained DIFFGMM&#34;" alt="&#34;covar of trained DIFFGMM&#34;"></p>

<p>さっき学習したGMMとは、共分散はかなり形が違いますね。高次元成分でも、分散が比較的大きな値をとっているように見えます。形が異っているのは見てすぐにわかりますが、では具体的には何が異っているのか、それはなぜなのか、きちんと考えると面白そうですね。</p>

<h3>5.2 MLSAフィルタによる声質変換</h3>

<p>差分スペクトル補正に基づく声質変換では、WORLDを使って音声の分析合成を行うのではなく、生の音声波形を入力として、MLSAフィルタをかけるのみです。これは、 <code>scripts/diffvc.jl</code> を使うと簡単にできます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>julia diffvc.jl ~/data/cmu_arctic/cmu_us_clb_arctic/wav/arctic_a0028.wav clb_to_slt_gmm32_order40_diff.jld clb_to_slt_a0028_diff.wav --order 40
</span></code></pre></td></tr></table></div></figure>


<p>さて、結果を聞いてみましょう。</p>

<h3>5.3 差分スペクトル補正に基づく声質変換結果</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/176093513&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>アイデアはシンプル、結果は良好、最高の手法ですね（べた褒め</p>

<h2>おわりに</h2>

<p>以上、長くなりましたが、統計的声質変換についてのチュートリアルはこれで終わります。誰の役に立つのか知らないけれど、役に立てば嬉しいです。トラジェクトリ変換やGVを考慮したバージョンなど、今回紹介していないものも実装しているので、詳しくは<a href="https://github.com/r9y9/VoiceConversion.jl">Githubのリポジトリ</a>をチェックしてください。バグをレポートしてくれたりすると、僕は喜びます。</p>

<h2>参考</h2>

<h3>以前書いた声質変換に関する記事</h3>

<ul>
<li><a href="http://r9y9.github.io/blog/2014/07/05/statistical-voice-conversion-muzui/">統計的声質変換クッソムズすぎワロタ &ndash; LESS IS MORE</a></li>
<li><a href="http://r9y9.github.io/blog/2014/07/13/statistical-voice-conversion-wakaran/">統計的声質変換クッソムズすぎワロタ（実装の話） &ndash; LESS IS MORE</a></li>
</ul>


<h3>論文</h3>

<ul>
<li><a href="http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf">[Toda 2007] T. Toda, A. W. Black, and K. Tokuda, “Voice conversion based on maximum likelihood estimation of spectral parameter trajectory,” IEEE
Trans. Audio, Speech, Lang. Process, vol. 15, no. 8, pp. 2222–2235,
Nov. 2007.</a></li>
<li><a href="http://isw3.naist.jp/~kazuhiro-k/resource/kobayashi14IS.pdf">[Kobayashi 2014] Kobayashi, Kazuhiro, et al. &ldquo;Statistical Singing Voice Conversion with Direct Waveform Modification based on the Spectrum Differential.&rdquo; Fifteenth Annual Conference of the International Speech Communication Association. 2014.</a></li>
</ul>


<h2>FAQ</h2>

<h3>前はpythonで書いてなかった？</h3>

<p>はい、<a href="https://gist.github.com/r9y9/88bda659c97f46f42525">https://gist.github.com/r9y9/88bda659c97f46f42525</a> ですね。正確には、GMMの学習・変換処理はpythonで書いて、特徴抽出、パラレルデータの作成、波形合成はGo言語で書いていました。が、Goとpythonでデータのやりとり、Goとpythonをいったり来たりするのが面倒になってしまって、一つの言語に統一したいと思うようになりました。Goで機械学習は厳しいと感じていたので、pythonで書くかなぁと最初は思ったのですが、WORLDやSPTKなど、Cのライブラリをpythonから使うのが思いの他面倒だったので（<a href="https://github.com/r9y9/SPTK">SPTKのpythonラッパー</a>は書きましたが）、Cやpythonとの連携がしやすく、スクリプト言語でありながらCに速度面で引けをとらないjuliaに興味があったので、juliaですべて完結するようにしました。かなり実験的な試みでしたが、今はかなり満足しています。juliaさいこー</p>

<h3>新規性は？</h3>

<p>ありません</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NMFで音源分離を試してみる]]></title>
    <link href="http://r9y9.github.io/blog/2014/10/19/nmf-music-source-separation/"/>
    <updated>2014-10-19T20:55:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/10/19/nmf-music-source-separation</id>
    <content type="html"><![CDATA[<p>ずーーっと前に、 <a href="http://r9y9.github.io/blog/2013/07/27/nmf-euclid/">NMFアルゴリズムの導出（ユークリッド距離版） &ndash; LESS IS MORE</a> で実際に実装してみてやってみると書いていたのに、まったくやっていなかったことに気づいたのでやりました。</p>

<p>音楽に対してやってみたのですが、簡単な曲だったら、まぁぼちぼち期待通りに動いたかなぁという印象です。コードとノートを挙げたので、興味のある方はどうぞ。</p>

<h2>Github</h2>

<p><a href="https://github.com/r9y9/julia-nmf-ss-toy">https://github.com/r9y9/julia-nmf-ss-toy</a></p>

<h2>ノート</h2>

<p><a href="http://nbviewer.ipython.org/github/r9y9/julia-nmf-ss-toy/blob/master/NMF-based%20Music%20Source%20Separation%20Demo.ipynb">NMF-based Music Source Separation Demo.ipynb | nbviewer</a></p>

<h2>NMFのコード (Julia)</h2>

<p>NMFの実装の部分だけ抜き出しておきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='julia'><span class='line'><span class="k">function</span><span class="nf"> nmf_euc</span><span class="p">(</span><span class="n">Y</span><span class="p">::</span><span class="n">AbstractMatrix</span><span class="p">,</span> <span class="n">K</span><span class="p">::</span><span class="kt">Int</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
</span><span class='line'>                        <span class="n">maxiter</span><span class="p">::</span><span class="kt">Int</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</span><span class='line'>    <span class="n">H</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">K</span><span class="p">)</span>
</span><span class='line'>    <span class="n">U</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>    <span class="kd">const</span> <span class="err">ϵ</span> <span class="o">=</span> <span class="mf">1.0e-21</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">maxiter</span>
</span><span class='line'>        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">.*</span> <span class="p">(</span><span class="n">Y</span><span class="o">*</span><span class="n">U</span><span class="o">&#39;</span><span class="p">)</span> <span class="o">./</span> <span class="p">(</span><span class="n">H</span><span class="o">*</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">&#39;</span> <span class="o">+</span> <span class="err">ϵ</span><span class="p">)</span>
</span><span class='line'>        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">.*</span> <span class="p">(</span><span class="n">H</span><span class="o">&#39;*</span><span class="n">Y</span><span class="p">)</span> <span class="o">./</span> <span class="p">(</span><span class="n">H</span><span class="o">&#39;*</span><span class="n">H</span><span class="o">*</span><span class="n">U</span> <span class="o">+</span> <span class="err">ϵ</span><span class="p">)</span>
</span><span class='line'>        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">./</span> <span class="n">maximum</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">U</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>いやー簡単ですねー。<a href="http://r9y9.github.io/blog/2013/07/27/nmf-euclid/">NMFアルゴリズムの導出（ユークリッド距離版） &ndash; LESS IS MORE</a> で導出した更新式ほぼそのままになってます（異なる点としては、ゼロ除算回避をしているのと、Uをイテレーション毎に正規化していることくらい）。</p>

<p>B3, B4くらいの人にとっては参考になるかもしれないと思ってあげてみた。</p>

<p>おわり</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JuliaTokyo #2でBinDeps.jl についてLTしてきた]]></title>
    <link href="http://r9y9.github.io/blog/2014/09/30/juliatokyo2/"/>
    <updated>2014-09-30T00:40:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/09/30/juliatokyo2</id>
    <content type="html"><![CDATA[<p><a href="juliatokyo.connpass.com/event/8010/">JuliaTokyo #2 &ndash; connpass</a></p>

<script async class="speakerdeck-embed" data-id="21106ae0285e01327810268beacd0cf3" data-ratio="1.77777777777778" src="http://r9y9.github.io//speakerdeck.com/assets/embed.js"></script>


<h2>発表概要</h2>

<p>C/C++ライブラリのラッパー（C++は現状のJuliaでは難しいけど）を作るときに、どうやってライブラリの依存関係を管理するか？という話です。結論としては、方法はいくつかありますが　BinDeps.jl というパッケージを使うのが楽で良いですよ、ということです。Githubのいろんなリポジトリをあさった僕の経験上、BinDeps.jl はバイナリの依存関係管理におけるデファクトスタンダードな気がしています。BinDeps.jl の使い方は、既存のパッケージのコードを読みまくって学ぶのがおすすめです。</p>

<p>さて、途中で書くのに疲れてしまったのですが、<a href="http://qiita.com/r9y9/items/73806e3ce7f3a372d0b3">自作のJuliaパッケージで、Cライブラリとの依存性を記述する &ndash; Qiita</a> に以前似たような内容をまとめたので、併せてどうぞ。qiitaにも書きましたが、最適化関係のプロジェクトを集めた <a href="http://www.juliaopt.org/">JuliaOpt</a> コミュニティでは、バイナリの依存関係管理にBinDeps.jlを使用することを推奨しています。</p>

<h2>雑感</h2>

<ul>
<li>勉強会にはデータ分析界隈の人が多い印象。音声系の人はとても少なかった。</li>
<li>R人気だった</li>
<li>Go使ってる！って人と合わなかった（つらい）</li>
<li>@show マクロ最高</li>
<li>unicode最高</li>
<li>懇親会では、なぜか途中から深層学習やベイズの話をしていた…</li>
<li>いい忘れたけど僕もnightly build勢でした。毎日あたたかみのある手動pull &amp; make をしています。</li>
<li>Julia の話ができて楽しかったので、また参加したいなー</li>
</ul>


<p>LTで <a href="https://github.com/chezou/MeCab.jl">MeCab.jl</a> について話をしてくれたchezouさんが、ちょうどBinDeps.jl に興味を持たれているようだったので、勉強会のあとに BinDeps.jl を使ってバイナリの管理を実装して、<a href="https://github.com/chezou/MeCab.jl/pull/2">プルリク</a>をしてみました。参考になればうれしいなーと思います。</p>

<p>おしまい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPTKのJuliaラッパーも書いた]]></title>
    <link href="http://r9y9.github.io/blog/2014/09/15/sptk-for-julia/"/>
    <updated>2014-09-15T01:25:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/09/15/sptk-for-julia</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://r9y9.github.io/images/IMG_0960.JPG" title="&#34;sea&#34;" alt="&#34;sea&#34;"></p>

<p>夏も終わったようですね。またSPTKかという感じですが、Juliaから使うためのラッパーを書きました。必要そうなのはだいたいラップしたので、よろしければどうぞ。</p>

<p><a href="https://github.com/r9y9/SPTK.jl">Julia wrapper for Speech Signal Processing Toolkit (SPTK) | Github</a></p>

<p>かれこれ、Go, Python, Juliaと、3つの言語でラッパーを書いてしまいました。どれだけSPTK好きなんだと。そしてどれだけ言語触ってるんだ絞れと。うーん、とはいえどれも良いところと悪いところがあってですね（何も言ってない）、難しい…</p>

<p>おしまい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最高の夏]]></title>
    <link href="http://r9y9.github.io/blog/2014/09/01/summer/"/>
    <updated>2014-09-01T01:01:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/09/01/summer</id>
    <content type="html"><![CDATA[<div align="center">
<blockquote class="twitter-tweet" lang="en"><p><a href="http://t.co/VMToqJ7PCB">pic.twitter.com/VMToqJ7PCB</a></p>&mdash; ノッツ@ソラミちゃんの唄②発売中 (@knotscream) <a href="https://twitter.com/knotscream/statuses/505861575933038592">August 30, 2014</a></blockquote>
<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>


<h2>収穫</h2>

<p>この夏いちばんの収穫はノッツさんという漫画家の方を知れたことだった。最高の夏だ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gamma Process Non-negative Matrix Factorization (GaP-NMF) in Julia]]></title>
    <link href="http://r9y9.github.io/blog/2014/08/20/gap-nmf-julia/"/>
    <updated>2014-08-20T15:30:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/08/20/gap-nmf-julia</id>
    <content type="html"><![CDATA[<p>最近 <a href="julialang.org">Julia</a> で遊んでいて、その過程で非負値行列因子分解（NMF）のノンパラ版の一つであるGamma Process Non-negative Matrix Factorization (GaP-NMF) を書いてみました。（まぁmatlabコードの写経なんですが）</p>

<p><a href="https://github.com/r9y9/BNMF.jl">https://github.com/r9y9/BNMF.jl</a></p>

<p>元論文:
 <a href="http://soundlab.cs.princeton.edu/publications/2010_icml_gapnmf.pdf">Bayesian Nonparametric Matrix Factorization for Recorded Music</a>
by Matthew D. Hoffman et al. in ICML 2010.</p>

<h2>デモ</h2>

<p><a href="http://nbviewer.ipython.org/github/r9y9/BNMF.jl/blob/master/notebook/GaP-NMF.ipynb">http://nbviewer.ipython.org/github/r9y9/BNMF.jl/blob/master/notebook/GaP-NMF.ipynb</a></p>

<p>適当な音声（音楽じゃなくてごめんなさい）に対して、GaP-NMFをfittingしてみた結果のメモです。$K=100$ で始めて、100回ほどイテレーションを回すと適度な数（12くらい）にtruncateしているのがわかると思います。予めモデルの複雑度を指定しなくても、データから適当な数を自動決定してくれる、ノンパラベイズの良いところですね。</p>

<h2>ハマったところ</h2>

<ul>
<li>GIGの期待値を求めるのに必要な第二種変形ベッセル関数は、exponentially scaled versionを使いましょう。じゃないとInf地獄を見ることになると思います（つらい）。Juliaで言うなら <a href="https://julia.readthedocs.org/en/latest/stdlib/base/?highlight=besselkx#Base.besselkx">besselkx</a> で、scipyで言うなら <a href="http://students.mimuw.edu.pl/~pbechler/scipy_doc/generated/scipy.special.kve.html#scipy.special.kve">scipy.special.kve</a> です。</li>
</ul>


<h2>雑感</h2>

<ul>
<li>MatlabのコードをJuliaに書き直すのは簡単。ところどころ作法が違うけど（例えば配列の要素へのアクセスはmatlabはA(i,j)でJuliaはA[i,j]）、だいたい一緒</li>
<li>というかJuliaがMatlabに似すぎ？</li>
<li>Gamma分布に従う乱数は、<a href="https://github.com/JuliaStats/Distributions.jl">Distributions,jl</a> を使えばめっちゃ簡単に生成できた。素晴らしすぎる</li>
<li>行列演算がシンプルにかけてホント楽。pythonでもmatlabでもそうだけど（Goだとこれができないんですよ…）</li>
<li>第二種変形ベッセル関数とか、scipy.special にあるような特殊関数が標準である。素晴らしい。</li>
</ul>


<h2>Python版と速度比較</h2>

<p><a href="https://github.com/dawenl/bp_nmf/tree/master/code/gap_nmf">bp_nmf/code/gap_nmf</a> と比較します。matlabはもってないので比較対象からはずします、ごめんなさい</p>

<p>Gistにベンチマークに使ったスクリプトと実行結果のメモを置いときました
<a href="https://gist.github.com/r9y9/3d0c6a90dd155801c4c1">https://gist.github.com/r9y9/3d0c6a90dd155801c4c1</a></p>

<p>結果だけ書いておくと、あらゆる現実を（ry の音声にGaP-NMFをepochs=100でfittingするのにかかった時間は、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Julia: Mean elapsed time: 21.92968243 [sec]
</span><span class='line'>Python: Mean elapsed time: 18.3550617 [sec]</span></code></pre></td></tr></table></div></figure>


<p>という結果になりました。つまりJuliaのほうが1.2倍くらい遅かった（僕の実装が悪い可能性は十分ありますが）。どこがボトルネックになっているのか調べていないので、気が向いたら調べます。Juliaの方が速くなったらいいなー</p>

<h2>おわりに</h2>

<p>GaP-NMFの実装チャレンジは二回目でした。（たぶん）一昨年、年末に実家に帰るときに、何を思ったのか急に実装したくなって、電車の中で論文を読んで家に着くなり実装するというエクストリームわけわからんことをしていましたが、その時はNaN and Inf地獄に負けてしまいました。Pythonで書いていましたが、今見るとそのコードマジクソでした。</p>

<p>そして二回目である今回、最初はmatlabコードを見ずに自力で書いていたんですが、またもやInf地獄に合いもうだめだと思って、matlabコードを写経しました。あんま成長していないようです（つらい）</p>

<p>Julia歴二週間くらいですが、良い感じなので使い続けて見ようと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夏休みと人生]]></title>
    <link href="http://r9y9.github.io/blog/2014/08/20/life/"/>
    <updated>2014-08-20T03:21:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/08/20/life</id>
    <content type="html"><![CDATA[<div align="center">
<blockquote class="twitter-tweet" lang="en"><p><a href="http://t.co/pm6uDKoAg6">pic.twitter.com/pm6uDKoAg6</a></p>&mdash; ノッツ@ソラミちゃんの唄②発売中 (@knotscream) <a href="https://twitter.com/knotscream/statuses/501511644359303168">August 18, 2014</a></blockquote>
<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>


<p><a href="http://snn.getnews.jp/archives/388418">http://snn.getnews.jp/archives/388418</a></p>

<p>こんな夏休みを過ごしたい人生だったよ</p>

<p>p.s.</p>

<p>速攻でノッツさんフォローしました</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPTKのPythonラッパーを書いた]]></title>
    <link href="http://r9y9.github.io/blog/2014/08/10/sptk-from-python/"/>
    <updated>2014-08-10T02:12:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/08/10/sptk-from-python</id>
    <content type="html"><![CDATA[<h2>2015/09/06 追記</h2>

<p>ましなpythonラッパーを新しく作りました: <a href="http://r9y9.github.io/blog/2015/09/06/pysptk/">Pysptk: SPTKのpythonラッパーを作った (Part 2) &ndash; LESS IS MORE</a></p>

<h2>2014/08/10 追記</h2>

<p>ipython notebookによる簡単なチュートリアルを貼っておきます</p>

<p><a href="http://nbviewer.ipython.org/github/r9y9/SPTK/blob/master/notebook/SPTK%20calling%20from%20python.ipynb">SPTK を Pythonから呼ぶ | nbviewer</a></p>

<h2>2014/11/09</h2>

<p>タイポ修正しました…</p>

<p>scipy.mixture &ndash;> sklearn.mixture</p>

<p>SPTKの中で最も価値がある（と僕が思っている）メルケプストラム分析、メルケプストラムからの波形合成（MLSA filter）がpythonから可能になります。</p>

<p>ご自由にどうぞ</p>

<p><a href="https://github.com/r9y9/SPTK">Speech Signal Processing Toolkit (SPTK) for API use with python | Github</a></p>

<p>注意ですが、<code>SPTK.h</code>にある関数を全部ラップしているわけではないです。僕が必要なものしか、現状はラップしていません（例えば、GMMとかラップする必要ないですよね？sklearn.mixture使えばいいし）。ただ、大方有用なものはラップしたと思います。</p>

<h2>参考</h2>

<ul>
<li><a href="http://r9y9.github.io/blog/2014/02/10/sptk-go-wrapper/">Goで音声信号処理をしたいのでSPTKのGoラッパーを書く &ndash; LESS IS MORE</a></li>
</ul>


<p>Goでも書いたのにPythonでも書いてしまった。</p>

<p>一年くらい前に元指導教員の先生と「Pythonから使えたらいいですよね」と話をしていました。先生、ようやく書きました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tokyo.Scipyに参加してきた]]></title>
    <link href="http://r9y9.github.io/blog/2014/08/05/tokyo-scipy/"/>
    <updated>2014-08-05T23:36:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/08/05/tokyo-scipy</id>
    <content type="html"><![CDATA[<h2><a href="https://github.com/tokyo-scipy/archive">Tokyo.SciPy</a></h2>

<p>ハッシュタグ: <a href="https://twitter.com/search?q=%23tokyoscipy&amp;src=tyah">#tokyoscipy</a></p>

<blockquote><p>Tokyo.Scipy は科学技術計算で Python を利用するための勉強会です．</p></blockquote>

<p>とのことです。最近、python/numpy/scipyによくお世話になっているので、参加してみました。雑感をメモしておきます。</p>

<h2><a href="https://github.com/tokyo-scipy/archive/tree/master/006">Tokyo.Scipy 006</a></h2>

<p>第6回のようでした。プログラムだけさっとまとめると、</p>

<ul>
<li>そこそこ大規模Python並列/パイプライン処理入門 w/o MapReduceレジーム (柏野雄太 @yutakashino) 45分</li>
<li>初心者が陥るN個の罠。いざ進めNumpy/Scipyの道 (@nezuq) 15分</li>
<li>Making computations reproducible (@fuzzysphere) 30分</li>
<li>IPython Notebookで始めるデータ分析と可視化 (杜世橋 @lucidfrontier45) 30分</li>
<li>PyMCがあれば，ベイズ推定でもう泣いたりなんかしない (神嶌敏弘 @shima__shima) 45分</li>
</ul>


<p>という感じ。僕的には、@shima__shima 先生の発表が目当てだった</p>

<h2>雑感</h2>

<ul>
<li>今回（？）はscipyの話はほとんどなかった。pythonを使った科学技術計算に関する幅広いトピックを扱ってる印象。</li>
<li>ipython はやっぱ便利ですね。僕も良く使います</li>
<li>@shima__shima 先生の発表がとてもわかりやすかったので、本当に参考にしたい</li>
<li>正直もっとコアな話もあっていいのでは、と思った</li>
<li>懇親会で気づいたが、意外と音声信号処理やってる（た）人がいてびっくりした</li>
<li><a href="https://github.com/scikit-learn/scikit-learn">scikit-learn</a> を初期の頃に作られてた方 <a href="https://twitter.com/cournape">@cournape</a> がいてびっくり。開発当初はGMMとSVMくらいしかなくて全然ユーザーがつかなかったなどなど、裏話を色々聞けた</li>
<li>フランス人の「たぶん大丈夫」は絶対無理の意（わろた</li>
<li>Rust, juliaがいいと教えてもらった。うちjuliaは今やってみてるがなかなかいい</li>
<li>発表でも話題に上がったけど、Pandasがいいという話を聞いたので、試してみたい</li>
</ul>


<p>運営の方々、発表された方々、ありがとうございました。僕も機会が合えば何か発表したい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goでニューラルネットいくつか書いたけどやっぱPythonが楽でいいですね]]></title>
    <link href="http://r9y9.github.io/blog/2014/07/29/neural-networks-in-go-and-python/"/>
    <updated>2014-07-29T22:00:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/07/29/neural-networks-in-go-and-python</id>
    <content type="html"><![CDATA[<p>いまいち成果出ないので気分転換にブログをだらだら書いてみるテストです。</p>

<h2>まえがき</h2>

<p>半年くらい前に、某深層学習に興味を持ってやってみようかなーと思っていた時期があって、その時にGoでいくつかニューラルネットを書きました（参考：<a href="http://r9y9.github.io/blog/2014/03/06/restricted-boltzmann-machines-mnist/">Restricted Boltzmann Machines with MNIST &ndash; LESS IS MORE</a>、<a href="https://github.com/r9y9/nnet">githubに上げたコード</a>）。なぜGoだったかというと、僕がGoに興味を持ち始めていたからというのが大きいです。Goを知る前は、たくさん計算するようなコードを書くときはC++だったけれど、C++は色々つらいものがあるし、GoはC++には速度面で劣るもののそこそこ速く、かつスクリプト的な書きやすさもあります。C++のデバッグやメンテに費やす膨大な時間に比べれば、計算時間が1.5~2倍に増えるくらい気にしないというスタンスで、僕はC++のかわりGoを使おうとしていました（※今でも間違っているとは思いませんが、とはいえ、厳しいパフォーマンスを求められる場合や既存の資産を有効活用したい場合など、必要な場面ではC++を書いています）。</p>

<h2>Goで機械学習</h2>

<p>僕は機械学習がけっこう好きなので、Goでコード書くかーと思っていたのですが、結果としてまったく捗りませんでした。ニューラルネットをてきとーに書いたくらいです。</p>

<p>検索するとわかりますが、現状、他の主流な言語に比べて圧倒的に数値計算のライブラリが少ないです。特に、線形代数、行列演算のデファクト的なライブラリがないのはつらいです。いくつか代表的なものをあげます。</p>

<ul>
<li><a href="https://github.com/skelterjohn/go.matrix">skelterjohn/go.matrix</a> &ndash; もうまったくメンテされていないし、たぶんするつもりはないと思います。使い勝手は、僕にとってはそんなに悪くなかった（試しに<a href="https://gist.github.com/r9y9/9030922">NMF</a>を書いてみた）ですが、実装は純粋なGoで書かれていて、GPUを使って計算するのが流行りな時代では、例えば大きなニューラルネットをパラメータを変えながら何度も学習するのにはしんどいと思いました。</li>
<li><a href="https://github.com/gonum/matrix">gonum/matrix</a> &ndash; 比較的最近出てきたライブラリで、<a href="https://code.google.com/p/biogo/">biogo</a> から行列演算に関する部分を切り出して作られたもののようです。行列演算の内部でblasを使っていて、かつ将来的にはcublasにも対応したい、みたいな投稿をGoogle Groupsで見たのもあって、半年くらい前にはgoで行列演算を行うならこのライブラリを使うべきだと判断しました（以前けっこう調べました：<a href="http://qiita.com/r9y9/items/7f93a89e3a88bb4ed263">gonum/matrix のデザインコンセプトに関するメモ &ndash; Qiita</a>）。しかし、それほど頻繁にアップデートされていませんし、機能もまだ少ないです。</li>
</ul>


<p>自分で作るかー、という考えも生まれなかったことはないですが、端的に言えばそれを行うだけのやる気がありませんでした。まぁ本当に必要だったら多少難しくてもやるのですが、ほら、僕達にはpythonがあるじゃないですか…</p>

<h2>Pythonで機械学習</h2>

<p><a href="https://www.google.co.jp/search?q=python+%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92&amp;oq=python+%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92">python 機械学習 &ndash; Google 検索</a> 約 119,000 件（2014/07/29現在）</p>

<p>もうみんなやってますよね。</p>

<p><a href="https://www.google.co.jp/search?q=Golang+%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92&amp;oq=Golang+%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92">Golang 機械学習 &ndash; Google 検索</a> 約 9,130 件（2014/07/29現在）</p>

<p>いつかpythonのように増えるんでしょうか。正直に言って、わかりません（正確には、あんま考えていませんごめんなさい）</p>

<p>さて、僕もよくpython使います。機械学習のコードを書くときは、だいたいpythonを使うようになりました（昔はC++で書いていました）。なぜかって、numpy, scipyのおかげで、とても簡潔に、かつ上手く書けばそこそこ速く書けるからです。加えて、ライブラリがとても豊富なんですよね、機械学習にかかわらず。numpy, scipyに加えて、matplotlibという優秀な描画ライブラリがあるのが、僕がpythonを使う大きな理由になっています。</p>

<p>pythonの機械学習ライブラリは、<a href="http://scikit-learn.org/stable/">scikit-learn</a> が特に有名でしょうか。僕もちょいちょい使います。使っていて最近おどろいたのは、scipy.mixtureには通常のGMMだけでなく変分GMM、無限混合GMMも入っていることですよね。自分で実装しようとしたら、たぶんとても大変です。昔変分GMMの更新式を導出したことがありますが、何度も心が折れそうになりました。いやー、いい時代になったもんですよ…（遠い目</p>

<h2>Pythonでニューラルネット（pylearn2を使おう）</h2>

<p>Deep何とかを含め流行りのニューラルネットが使える機械学習のライブラリでは、僕は <a href="https://github.com/lisa-lab/pylearn2">pylearn2</a> がよさ気だなーと思っています。理由は、高速かつ拡張性が高いからです。pylearn2は、数学的な記号表現からGPUコード（GPUがなければCPU向けのコード）を生成するmathコンパイラ <a href="https://github.com/Theano/Theano">Theano</a> で書かれているためpythonでありながら高速で、かつ機械学習に置いて重要なコンポーネントであるデータ、モデル、アルゴリズムが上手く分離されて設計されているのがいいところかなと思います（全部ごっちゃに書いていませんか？僕はそうですごめんなさい。データはともかくモデルと学習を上手く切り分けるの難しい）。A Machine Learning library based on Theanoとのことですが、Deep learningで有名な <a href="http://lisa.iro.umontreal.ca/index_en.html">lisa lab</a> 発ということもあり、ニューラルネットのライブラリという印象が少し強いですね。</p>

<p>一つ重要なこととして、このライブラリはかなり研究者向けです。ブラックボックスとして使うのではなく、中身を読んで必要に応じて自分で拡張を書きたい人に向いているかと思います。</p>

<p><a href="http://arxiv.org/pdf/1308.4214v1.pdf">Ian J. Goodfellow, David Warde-Farley, Pascal Lamblin, Vincent Dumoulin, Mehdi Mirza, Razvan Pascanu, James Bergstra, Frédéric Bastien, and Yoshua Bengio. “Pylearn2: a machine learning research library”. arXiv preprint arXiv:1308.4214</a></p>

<p>↑の論文のIntroductionの部分に、その旨は明記されています。と、論文のリンクを貼っておいてなんですが、<a href="http://www-etud.iro.umontreal.ca/~goodfeli/">Ian Goodfellow</a> のホームページにもっと簡潔に書いてありました。以下、引用します。</p>

<blockquote><p>I wrote most of Pylearn2, a python library designed to make machine learning research convenient. Its mission is to provide a toolbox of interchangeable parts that provide a lot of flexibility for setting up machine learning experiments, providing enough extensibility that pretty much any research idea is feasible within the context of the library. This is in contrast to other machine learning libraries such as scikits-learn that are designed to be black boxes that just work. Think of pylearn2 as user friendly for machine learning researchers and scikits-learn as user friendly for developers that want to apply machine learning.</p></blockquote>

<p>pylearn2では、Multi-layer Perceptron (MLP)、Deep Bolztmann Machines (DBM)、新しいものでMaxout Network等、手軽に試すことができます（まぁゆうて計算はめっちゃ時間かかるけど）。先述の通りmathコンパイラの <a href="https://github.com/Theano/Theano">Theano</a> を使って実装されているので、GPUがある場合はGPUを使って計算してくれます。環境構築に関しては、今はAWSという便利なサービスがあるので、GPUを持っていなくてもウェブ上でポチポチしてるだけで簡単にGPU環境を構築できます（参考：<a href="http://r9y9.github.io/blog/2014/07/20/pylearn2-on-ec2-g2-2xlarge/">Pylearn2, theanoをEC2 g2.x2large で動かす方法 &ndash; LESS IS MORE</a>）。本当にいい時代になったものですね（二回目</p>

<p>pylearn2、コードやドキュメント、活発なgithubでの開発、議論を見ていて、素晴らしいなーと思いました（まだ使い始めたばかりの僕の意見にあまり信憑性はないのですが…）。僕もこれくらい汎用性、拡張性のあるコードを書きたい人生でした…（自分の書いたニューラルネットのコードを見ながら）</p>

<h2>Pylearn2は遅いって？</h2>

<p>本当に速さを求めるなら <a href="https://code.google.com/p/cuda-convnet2/">cuda-convnet2</a> や <a href="http://caffe.berkeleyvision.org/">Cafee</a>、もしくは直でcudaのAPIをだな…と言いたいところですが、確かにpylearn2は他の深層学習のライブラリに比べて遅いようです。最近、Convolutional Neural Network (CNN) に関するベンチマークがGithubで公開されていました。</p>

<p><a href="https://github.com/soumith/convnet-benchmarks">soumith/convnet-benchmarks</a></p>

<p>現時点でまだ work in progressと書いてありますが、参考になると思います。優劣の問題ではなく、必要に応じて使い分ければいいと僕は思っています。</p>

<p>さてさて、本当はここから僕が書いたGoのニューラルネットのコードがいかにクソかという話を書こうかと思ったのですが、長くなったのでまた今度にします。</p>

<h2>まとめ</h2>

<ul>
<li>Goでニューラルネットとか機械学習をやるのは現状しんどいし（<a href="https://github.com/sjwhitworth/golearn">golearn</a>とかあるけど、まだまだearly stage）、おとなしくpython使うのが無難</li>
<li>pythonはやっぱり楽。ライブラリ豊富だし。ニューラルネットならpylearn2がおすすめ。ただし自分で拡張まで書きたい人向けです。</li>
</ul>


<p>散々pythonいいよゆうてますが、どちらかといえば僕はGoの方が好きです。機械学習には現状pythonを使うのがいいんじゃないかなーと思って、Goでニューラルネットを書いていた時を思い出しながらつらつらと書いてみました。</p>

<p>おわり。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pylearn2, theanoをEC2 g2.x2large で動かす方法]]></title>
    <link href="http://r9y9.github.io/blog/2014/07/20/pylearn2-on-ec2-g2-2xlarge/"/>
    <updated>2014-07-20T23:22:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/07/20/pylearn2-on-ec2-g2-2xlarge</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://r9y9.github.io/images/dbm_learned_from_mnist.png" title="&#34;Weight visualization of Restricted bolztomann machine trained on MNIST dataset.&#34;" alt="&#34;Weight visualization of Restricted bolztomann machine trained on MNIST dataset.&#34;"></p>

<h2>モチベーション</h2>

<ul>
<li>手元のへぼマシンでニューラルネットの学習を回わす</li>
<li>半日たっても終わらない</li>
<li>最近だとGPU使って計算を高速化するのが流行りだが、手元にGPUはない</li>
</ul>


<p><a href="http://www.kurtsp.com/deep-learning-in-python-with-pylearn2-and-amazon-ec2.html">Deep Learning in Python with Pylearn2 and Amazon EC2</a></p>

<p>手元にGPUがない…？大丈夫！Amazon EC2を使えば良さそう！！！</p>

<p>というわけで、めんどくさいと言わずにec2にお手軽計算環境を整えます。ec2でGPUが乗ったものだと、g2.2xlargeがよさそうですね。</p>

<p>ちなみに↑の図、pylearn2のtutorialのRestricted Bolzmann MachinesをMNISTで学習した結果なんですが、手元のマシンだとだいたい6時間くらい？（忘れた）だったのがg2.2xlargeだと30分もかかってない（ごめんなさい時間図るの忘れた）。$0.65/hourと安いんだし（他のインスタンスに比べればそりゃ高いけど）、もう手元のマシンで計算するの時間の無駄だしやめようと思います。</p>

<p>さてさて、今回環境構築に少しはまったので、もうはまらないように簡単にまとめておきます。</p>

<h2>結論</h2>

<p><a href="https://aws.amazon.com/marketplace/pp/B00FYCDDTE">Amazon Linux AMI with NVIDIA GRID GPU Driver on AWS Marketplace </a></p>

<p>すでにNVIDIAのドライバとCUDA（5.5）が入ったインスタンスをベースに使いましょう。</p>

<p><a href="http://xanxys.hatenablog.jp/entry/2014/05/17/135932">EC2(g2.2xlarge)でOpenGLを使う方法</a> で挙げられているように普通のlinuxを使う方法もありますが、ハマる可能性大です。僕はubuntuが使いたかったので最初はubuntu 14.04 server でドライバ、cuda (5.5 or 6.0) のインストールを試しましたが同じように失敗しました。</p>

<p>イケイケと噂の音声認識ライブラリKaldiの<a href="https://220-135-252-130.hinet-ip.hinet.net/speechwiki/index.php/Kaldi#installing_and_testing_CUDA-6.0_in_Ubuntu_14.04">ドキュメントらしきもの</a>を見ると、Ubuntu 14.04でもcuda 6.0インストールできるっぽいんですけどね…だめでした。頑張ればできるかもしれませんが、よほど強いメリットがない場合は、おとなしくpre-installされたインスタンスを使うのが吉だと思います。</p>

<h2>セットアップ</h2>

<p>↑で上げたインスタンスにはGPUドライバやCUDAは入っていますが、theanoもpylearn2もnumpyもscipyも入っていません。よって、それらは手動でインストールする必要があります。</p>

<p>というわけで、インストールするシェルをメモって置きます。試行錯誤したあとに適当にまとめたshellなので、なんか抜けてたらごめんなさい。</p>

<p><a href="https://gist.github.com/r9y9/50f13ba28b5b158c25ae">https://gist.github.com/r9y9/50f13ba28b5b158c25ae</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Pylearn2 setup script for Amazon Linux AMI with NVIDIA GRID GPU Driver.</span>
</span><span class='line'><span class="c"># http://goo.gl/3KeXXW</span>
</span><span class='line'>
</span><span class='line'>sudo yum update -y
</span><span class='line'>sudo yum install -y emacs tmux python-pip
</span><span class='line'>sudo yum install -y python-devel git blas-devel lapack-devel
</span><span class='line'>
</span><span class='line'><span class="c"># numpy, scipy, matplotlib, etc.</span>
</span><span class='line'>sudo pip install numpy
</span><span class='line'>sudo pip install scipy
</span><span class='line'>sudo pip install cython
</span><span class='line'>sudo pip install ipython nose
</span><span class='line'>
</span><span class='line'><span class="c"># matplotlib</span>
</span><span class='line'>sudo yum install -y libpng-devel freetype-devel
</span><span class='line'>sudo pip install matplotlib
</span><span class='line'>
</span><span class='line'><span class="c"># Scikit-learn</span>
</span><span class='line'>sudo pip install scikit-learn
</span><span class='line'>
</span><span class='line'><span class="c"># Theano</span>
</span><span class='line'>sudo pip install --upgrade git+git://github.com/Theano/Theano.git
</span><span class='line'>
</span><span class='line'><span class="c"># Enable GPU for theano</span>
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;[global]</span>
</span><span class='line'><span class="s1">floatX = float32</span>
</span><span class='line'><span class="s1">device = gpu0</span>
</span><span class='line'>
</span><span class='line'><span class="s1">[nvcc]</span>
</span><span class='line'><span class="s1">fastmath = True&#39;</span> &gt; .theanorc
</span><span class='line'>
</span><span class='line'><span class="c"># pylearn2</span>
</span><span class='line'>git clone git://github.com/lisa-lab/pylearn2.git
</span><span class='line'><span class="nb">cd </span>pylearn2
</span><span class='line'>sudo python setup.py develop
</span><span class='line'><span class="nb">cd</span> ..
</span><span class='line'>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;export PYLEARN2_DATA_PATH=/home/ec2-user/data&quot;</span> &gt;&gt; .bashrc
</span><span class='line'>
</span><span class='line'><span class="c"># MNIST dataset</span>
</span><span class='line'>mkdir -p data/mnist/
</span><span class='line'><span class="nb">cd </span>data/mnist/
</span><span class='line'>wget http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
</span><span class='line'>gunzip train-images-idx3-ubyte.gz
</span><span class='line'>wget http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz
</span><span class='line'>gunzip train-labels-idx1-ubyte.gz
</span><span class='line'>wget http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz
</span><span class='line'>gunzip t10k-images-idx3-ubyte.gz
</span><span class='line'>wget http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz
</span><span class='line'>gunzip t10k-labels-idx1-ubyte.gz
</span><span class='line'><span class="nb">cd</span> ../..
</span></code></pre></td></tr></table></div></figure>


<p>簡単ですね</p>

<p>また、上記のような手順を踏まなくても、Community AMIs でpylearn2で検索するとすでにpylearn2が入ったAMIが出てくるので、それを使うのもありかもです（僕は試してません）。</p>

<p>僕がAMIを公開してもいいんですが、今のところする予定はありません</p>

<h1>まとめ</h1>

<p>そこそこ良い計算環境がさくっとできました、まる。ラーメン食べたい</p>

<h2>参考</h2>

<ul>
<li><a href="http://aws.amazon.com/jp/ec2/instance-types/">インスタンスタイプ &ndash; Amazon EC2 (クラウド上の仮想サーバー Amazon Elastic Compute Cloud) | アマゾン ウェブ サービス（AWS 日本語）</a></li>
<li><a href="http://www.kurtsp.com/deep-learning-in-python-with-pylearn2-and-amazon-ec2.html">Deep Learning in Python with Pylearn2 and Amazon EC2</a></li>
<li><a href="http://xanxys.hatenablog.jp/entry/2014/05/17/135932">EC2(g2.2xlarge)でOpenGLを使う方法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[統計的声質変換クッソムズすぎワロタ（実装の話）]]></title>
    <link href="http://r9y9.github.io/blog/2014/07/13/statistical-voice-conversion-wakaran/"/>
    <updated>2014-07-13T02:02:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/07/13/statistical-voice-conversion-wakaran</id>
    <content type="html"><![CDATA[<p>2014/07/28 追記：<br/>
重み行列の構築の部分を改良したのでちょいアップデート。具体的にはdense matrixとして構築してからスパース行列に変換していたのを、はじめからスパース行列として構築するようにして無駄にメモリを使わないようにしました。あとdiffが見やすいようにgistにあげました
<a href="https://gist.github.com/r9y9/88bda659c97f46f42525">https://gist.github.com/r9y9/88bda659c97f46f42525</a></p>

<h2>まえがき</h2>

<p>前回、<a href="http://r9y9.github.io/blog/2014/07/05/statistical-voice-conversion-muzui/">統計的声質変換クッソムズすぎワロタ &ndash; LESS IS MORE</a> という記事を書いたら研究者の方々等ちょいちょい反応してくださって嬉しかったです。差分スペクトル補正、その道の人が聴いても音質がいいそう。これはいい情報です。</p>

<p>Twitter引用:</p>

<blockquote class="twitter-tweet" lang="en"><p>統計的声質変換クッソムズすぎワロタ - LESS IS MORE <a href="http://t.co/8RkeXIf6Ym">http://t.co/8RkeXIf6Ym</a> <a href="https://twitter.com/r9y9">@r9y9</a>さんから ムズすぎと言いながら，最後の音はしっかり出ているあたり凄いなぁ．</p>&mdash; M. Morise (忍者系研究者) (@m_morise) <a href="https://twitter.com/m_morise/statuses/485339123171852289">July 5, 2014</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/ballforest">@ballforest</a> 従来のパラメータ変換と比較すると、音質は従来よりもよさそうな気はしますがスペクトル包絡の性差ががっつりと影響しそうな気もするんですよね。</p>&mdash; 縄文人（妖精系研究者なのです） (@dicekicker) <a href="https://twitter.com/dicekicker/statuses/485380534122463232">July 5, 2014</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>異性間に関しては、実験が必要ですね。異性間だとF0が結構変わってくると思いますが、差分スペクトル補正の場合そもそもF0をいじらないという前提なので、F0とスペクトル包絡が完全に独立でない（ですよね？）以上、同姓間に比べて音質は劣化する気はします。簡単にやったところ、少なくとも僕の主観的には劣化しました</p>

<p>ところで、結構いい感じにできたぜひゃっはーと思って、先輩に聞かせてみたら違いわかんねと言われて心が折れそうになりました。やはり現実はつらいです。</p>

<h2>実装の話</h2>

<p>さて、今回は少し実装のことを書こうと思います。学習&amp;変換部分はPythonで書いています。その他はGo（※Goの話は書きません）。</p>

<h2>トラジェクトリベースのパラメータ変換が遅いのは僕の実装が悪いからでした本当に申し訳ありませんでしたorz</h2>

<p>前回トラジェクトリベースは処理が激重だと書きました。なんと、4秒程度の音声（フレームシフト5msで777フレーム）に対して変換部分に600秒ほどかかっていたのですが（重すぎワロタ）、結果から言えばPythonでも12秒くらいまでに高速化されました（混合数64, メルケプの次元数40+デルタ=80次元、分散共分散はfull）。本当にごめんなさい。</p>

<p>何ヶ月か前、ノリでトラジェクトリベースの変換を実装しようと思ってサクッと書いたのがそのままで、つまりとても効率の悪い実装になっていました。具体的には放置していた問題が二つあって、</p>

<ul>
<li>ナイーブな逆行列の計算</li>
<li>スパース性の無視</li>
</ul>


<p>です。特に後者はかなりパフォーマンスに影響していました</p>

<h2>ナイーブな逆行列の計算</h2>

<p><a href="http://d.hatena.ne.jp/sleepy_yoshi/20120513/p1">numpy.linalg.invとnumpy.linalg.solveを用いた逆行列計算 &ndash; 睡眠不足？！ (id:sleepy_yoshi)</a></p>

<p><code>numpy.linalg.inv</code>を使っていましたよね。しかも<code>numpy.linalg.solve</code>のほうが速いことを知っていながら。一ヶ月前の自分を問い詰めたい。<code>numpy.linalg.solve</code>で置き換えたら少し速くなりました。</p>

<ul>
<li>600秒 &ndash;> 570秒 （うろ覚え）</li>
</ul>


<p>1.05倍の高速化（微妙）</p>

<h2>スパース性の無視</h2>

<ul>
<li><a href="http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf">T. Toda, A. W. Black, and K. Tokuda, “Voice conversion based on maximum likelihood estimation of spectral parameter trajectory,” IEEE Trans. Audio, Speech, Lang. Process, vol. 15, no. 8, pp. 2222–2235, Nov. 2007</a>.</li>
</ul>


<p>論文を見ていただければわかるのですが、トラジェクトリベースの変換法における多くの計算は、行列を使って表すことができます。で、論文中の$W$という行列は、サイズがめちゃくちゃでかいのですがほとんどの要素は0です。この性質を使わない理由はないですよね？？</p>

<p>…残念なことに、僕は密行列として扱って計算していました。ほら、疎行列ってちょっと扱いづらいじゃないですか…めんどくさそう…と思って放置してました。ごめんなさい</p>

<p>pythonで疎行列を扱うなら、scipy.sparseを使えば良さそうです。結果、$W$を疎行列として扱うことで行列演算は大きく高速化されました。</p>

<ul>
<li>570秒 &ndash;> 12秒くらい</li>
</ul>


<p>単純に考えると50倍の高速化ですか。本当にアホだった。最初からscipy.sparse使っておけばよかったです。</p>

<p>scipy.sparseの使い方は以下を参考にしました。みなさんぜひ使いましょう</p>

<ul>
<li><a href="http://sucrose.hatenablog.com/entry/2013/04/07/130625">Python で疎行列(SciPy) &ndash; 唯物是真 @Scaled_Wurm</a></li>
<li><a href="http://docs.scipy.org/doc/scipy/reference/sparse.html">Sparse matrices (scipy.sparse) — SciPy v0.14.0 Reference Guide</a></li>
<li><a href="http://lucidfrontier45.wordpress.com/2011/08/02/scipysparse_matmul/">scipy.sparseで疎行列の行列積 | frontier45</a></li>
</ul>


<h2>コード</h2>

<p>メモ的な意味で主要なコードを貼っておきます。
<a href="https://gist.github.com/r9y9/88bda659c97f46f42525">https://gist.github.com/r9y9/88bda659c97f46f42525</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/python</span>
</span><span class='line'><span class="c"># coding: utf-8</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GMM</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scipy.linalg</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scipy.sparse</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">GMMMap</span><span class="p">:</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;GMM-based frame-by-frame speech parameter mapping. </span>
</span><span class='line'>
</span><span class='line'><span class="sd">    GMMMap represents a class to transform spectral features of a source</span>
</span><span class='line'><span class="sd">    speaker to that of a target speaker based on Gaussian Mixture Models</span>
</span><span class='line'><span class="sd">    of source and target joint spectral features.</span>
</span><span class='line'><span class="sd">    </span>
</span><span class='line'><span class="sd">    Notation</span>
</span><span class='line'><span class="sd">    --------</span>
</span><span class='line'><span class="sd">    Source speaker&#39;s feature: X = {x_t}, 0 &lt;= t &lt; T</span>
</span><span class='line'><span class="sd">    Target speaker&#39;s feature: Y = {y_t}, 0 &lt;= t &lt; T</span>
</span><span class='line'><span class="sd">    where T is the number of time frames.</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Parameters</span>
</span><span class='line'><span class="sd">    ----------</span>
</span><span class='line'><span class="sd">    gmm : scipy.mixture.GMM</span>
</span><span class='line'><span class="sd">        Gaussian Mixture Models of source and target joint features</span>
</span><span class='line'><span class="sd">    </span>
</span><span class='line'><span class="sd">    swap : bool</span>
</span><span class='line'><span class="sd">        True: source -&gt; target</span>
</span><span class='line'><span class="sd">        False target -&gt; source</span>
</span><span class='line'><span class="sd">    </span>
</span><span class='line'><span class="sd">    Attributes</span>
</span><span class='line'><span class="sd">    ----------</span>
</span><span class='line'><span class="sd">    num_mixtures : int</span>
</span><span class='line'><span class="sd">        the number of Gaussian mixtures</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    weights : array, shape (`num_mixtures`)</span>
</span><span class='line'><span class="sd">        weights for each gaussian</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    src_means : array, shape (`num_mixtures`, `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        means of GMM for a source speaker</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    tgt_means : array, shape (`num_mixtures`, `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        means of GMM for a target speaker</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    covarXX : array, shape (`num_mixtures`, `order of spectral feature`, </span>
</span><span class='line'><span class="sd">        `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        variance matrix of source speaker&#39;s spectral feature</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    covarXY : array, shape (`num_mixtures`, `order of spectral feature`, </span>
</span><span class='line'><span class="sd">        `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        covariance matrix of source and target speaker&#39;s spectral feature</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    covarYX : array, shape (`num_mixtures`, `order of spectral feature`, </span>
</span><span class='line'><span class="sd">        `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        covariance matrix of target and source speaker&#39;s spectral feature</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    covarYY : array, shape (`num_mixtures`, `order of spectral feature`, </span>
</span><span class='line'><span class="sd">        `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        variance matrix of target speaker&#39;s spectral feature</span>
</span><span class='line'><span class="sd">    </span>
</span><span class='line'><span class="sd">    D : array, shape (`num_mixtures`, `order of spectral feature`, </span>
</span><span class='line'><span class="sd">        `order of spectral feature`)</span>
</span><span class='line'><span class="sd">        covariance matrices of target static spectral features</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    px : scipy.mixture.GMM</span>
</span><span class='line'><span class="sd">        Gaussian Mixture Models of source speaker&#39;s features</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Reference</span>
</span><span class='line'><span class="sd">    ---------</span>
</span><span class='line'><span class="sd">      - [Toda 2007] Voice Conversion Based on Maximum Likelihood Estimation</span>
</span><span class='line'><span class="sd">        of Spectral Parameter Trajectory.</span>
</span><span class='line'><span class="sd">        http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gmm</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># D is the order of spectral feature for a speaker</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">weights_</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Split source and target parameters from joint GMM</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">D</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">tgt_means</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="p">[:,</span> <span class="n">D</span><span class="p">:]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">covars_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">D</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">covarXY</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">covars_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">:]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">covars_</span><span class="p">[:,</span> <span class="n">D</span><span class="p">:,</span> <span class="p">:</span><span class="n">D</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">covarYY</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">covars_</span><span class="p">[:,</span> <span class="n">D</span><span class="p">:,</span> <span class="n">D</span><span class="p">:]</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># swap src and target parameters</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">swap</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">tgt_means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgt_means</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">covarYY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarYY</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Compute D eq.(12) in [Toda 2007]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">):</span>
</span><span class='line'>            <span class="n">xx_inv_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXY</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarYY</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">xx_inv_xy</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># p(x), which is used to compute posterior prob. for a given source</span>
</span><span class='line'>        <span class="c"># spectral feature in mapping stage.</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">px</span> <span class="o">=</span> <span class="n">GMM</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">,</span> <span class="n">covariance_type</span><span class="o">=</span><span class="s">&quot;full&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="o">.</span><span class="n">means_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="o">.</span><span class="n">covars_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="o">.</span><span class="n">weights_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        Mapping source spectral feature x to target spectral feature y </span>
</span><span class='line'><span class="sd">        so that minimize the mean least squared error.</span>
</span><span class='line'><span class="sd">        More specifically, it returns the value E(p(y|x)].</span>
</span><span class='line'>
</span><span class='line'><span class="sd">        Parameters</span>
</span><span class='line'><span class="sd">        ----------</span>
</span><span class='line'><span class="sd">        src : array, shape (`order of spectral feature`)</span>
</span><span class='line'><span class="sd">            source speaker&#39;s spectral feature that will be transformed</span>
</span><span class='line'>
</span><span class='line'><span class="sd">        Return</span>
</span><span class='line'><span class="sd">        ------</span>
</span><span class='line'><span class="sd">        converted spectral feature</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Eq.(11)</span>
</span><span class='line'>        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mixtures</span><span class="p">):</span>
</span><span class='line'>            <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">src</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>            <span class="n">E</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgt_means</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Eq.(9) p(m|x)</span>
</span><span class='line'>        <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Eq.(13) conditinal mean E[p(y|x)]</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">posterior</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TrajectoryGMMMap</span><span class="p">(</span><span class="n">GMMMap</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    Trajectory-based speech parameter mapping for voice conversion</span>
</span><span class='line'><span class="sd">    based on the maximum likelihood criterion.</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Parameters</span>
</span><span class='line'><span class="sd">    ----------</span>
</span><span class='line'><span class="sd">    gmm : scipy.mixture.GMM</span>
</span><span class='line'><span class="sd">        Gaussian Mixture Models of source and target speaker joint features</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    gv : scipy.mixture.GMM (default=None)</span>
</span><span class='line'><span class="sd">        Gaussian Mixture Models of target speaker&#39;s global variance of spectral</span>
</span><span class='line'><span class="sd">        feature</span>
</span><span class='line'><span class="sd">    </span>
</span><span class='line'><span class="sd">    swap : bool (default=False)</span>
</span><span class='line'><span class="sd">        True: source -&gt; target</span>
</span><span class='line'><span class="sd">        False target -&gt; source</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Attributes</span>
</span><span class='line'><span class="sd">    ----------</span>
</span><span class='line'><span class="sd">    TODO </span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Reference</span>
</span><span class='line'><span class="sd">    ---------</span>
</span><span class='line'><span class="sd">      - [Toda 2007] Voice Conversion Based on Maximum Likelihood Estimation</span>
</span><span class='line'><span class="sd">        of Spectral Parameter Trajectory.</span>
</span><span class='line'><span class="sd">        http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gmm</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">gv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
</span><span class='line'>        <span class="n">GMMMap</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gmm</span><span class="p">,</span> <span class="n">swap</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span>
</span><span class='line'>        <span class="c"># shape[1] = d(src) + d(src_delta) + d(tgt) + d(tgt_delta)</span>
</span><span class='line'>        <span class="n">D</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span>
</span><span class='line'>
</span><span class='line'>        <span class="c">## Setup for Trajectory-based mapping</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">__construct_weight_matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c">## Setup for GV post-filtering</span>
</span><span class='line'>        <span class="c"># It is assumed that GV is modeled as a single mixture GMM</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">gv</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">gv_mean</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">means_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">gv_covar</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">covars_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">Pv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gv_covar</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__construct_weight_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># Construct Weight matrix W</span>
</span><span class='line'>        <span class="c"># Eq.(25) ~ (28)</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
</span><span class='line'>            <span class="n">w0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">))</span>
</span><span class='line'>            <span class="n">w1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">))</span>
</span><span class='line'>            <span class="n">w0</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span><span class="n">t</span><span class="o">*</span><span class="n">D</span><span class="p">:(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</span><span class='line'>                <span class="n">tmp</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>                <span class="n">w1</span><span class="p">[</span><span class="mi">0</span><span class="p">:,(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">:</span><span class="n">t</span><span class="o">*</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
</span><span class='line'>                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</span><span class='line'>                <span class="n">tmp</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>                <span class="n">w1</span><span class="p">[</span><span class="mi">0</span><span class="p">:,(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">:(</span><span class="n">t</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">W_t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">w0</span><span class="p">,</span> <span class="n">w1</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>            <span class="c"># Slower</span>
</span><span class='line'>            <span class="c"># self.W[2*D*t:2*D*(t+1),:] = W_t</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">W_t</span>
</span><span class='line'>            <span class="k">else</span><span class="p">:</span>
</span><span class='line'>                <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">W_t</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        Mapping source spectral feature x to target spectral feature y </span>
</span><span class='line'><span class="sd">        so that maximize the likelihood of y given x.</span>
</span><span class='line'>
</span><span class='line'><span class="sd">        Parameters</span>
</span><span class='line'><span class="sd">        ----------</span>
</span><span class='line'><span class="sd">        src : array, shape (`the number of frames`, `the order of spectral feature`)</span>
</span><span class='line'><span class="sd">            a sequence of source speaker&#39;s spectral feature that will be</span>
</span><span class='line'><span class="sd">            transformed</span>
</span><span class='line'>
</span><span class='line'><span class="sd">        Return</span>
</span><span class='line'><span class="sd">        ------</span>
</span><span class='line'><span class="sd">        a sequence of transformed spectral features</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="n">T</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="n">T</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">__construct_weight_matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># A suboptimum mixture sequence  (eq.37)</span>
</span><span class='line'>        <span class="n">optimum_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Compute E eq.(40)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">D</span><span class="p">))</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
</span><span class='line'>            <span class="n">m</span> <span class="o">=</span> <span class="n">optimum_mix</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="c"># estimated mixture index at time t</span>
</span><span class='line'>            <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">src</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_means</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>            <span class="c"># Eq. (22)</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgt_means</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">xx</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Compute D eq.(41). Note that self.D represents D^-1.</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">D</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">D</span><span class="p">))</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
</span><span class='line'>            <span class="n">m</span> <span class="o">=</span> <span class="n">optimum_mix</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</span><span class='line'>            <span class="n">xx_inv_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarXX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarXY</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>            <span class="c"># Eq. (23)</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covarYY</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarYX</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">xx_inv_xy</span><span class="p">)</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># represent D as a sparse matrix</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Compute target static features</span>
</span><span class='line'>        <span class="c"># eq.(39)</span>
</span><span class='line'>        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">))</span>
</span><span class='line'>        <span class="n">y</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">covar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">)),</span>\
</span><span class='line'>                                        <span class="n">use_umfpack</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>結論</h2>

<ul>
<li>疎行列の演算を考えるときは、間違ってもめんどくさいとか思わずに疎行列を積極的に使おう</li>
<li>統計的声質変換ムズすぎ</li>
</ul>


<h2>おまけめも</h2>

<p>僕が変換精度を改善するために考えていることのめも</p>

<ul>
<li>統計的な手法を使う限りover-smoothingの問題はついてくる。ならば、逆にover-smoothingされることで都合の良い特徴量を考えることはできないか</li>
<li>メルケプとかそもそもスペクトル包絡をコンパクトにparamtricに表現するために考えられたもの（だと思ってる）ので、高品質な変換を考えるならばスペクトル包絡をそのまま使うなりした方がいいんじゃないか。とはいえスペクトル包絡をそのまま使うのはぼちぼち高次元なので、個人性に依存する部分を残した形で非線形次元削減したらどうか（例えばニューラルネットを使って統計的に個人性に依存する部分を見つけ出すとか）</li>
<li>time-dependentな関係をモデル化しないとだめじゃないか、確率モデルとして。RNNとか普通に使えそうだし、まぁHMMでもよい</li>
<li>音素境界を推定して、segment単位で変換するのも良いかも</li>
<li>識別モデルもっと使ってもいいんじゃないか</li>
<li>波形合成にSPTKのmlsadfコマンド使ってる？あれ実はフレーム間のメルケプが線形補間されてるんですよね。本当に線形補間でいいんでしょうか？他の補間法も試したらどうですかね</li>
</ul>


<p>こんなかんじですか。おやすみなさい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[統計的声質変換クッソムズすぎワロタ]]></title>
    <link href="http://r9y9.github.io/blog/2014/07/05/statistical-voice-conversion-muzui/"/>
    <updated>2014-07-05T16:48:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/07/05/statistical-voice-conversion-muzui</id>
    <content type="html"><![CDATA[<h2>2014/10/12 追記</h2>

<p>少なくともGVのコードに致命的なバグがあったことがわかりました。よって、あまりあてにしないでください…（ごめんなさい</p>

<p>こんにちは。</p>

<p>最近、統計的声質変換の勉強をしていました。で、メジャーなGMM（混合ガウスモデル）ベースの変換を色々やってみたので、ちょろっと書きます。実は（というほどでもない?）シンプルなGMMベースの方法だと音質クッソ悪くなってしまうんですが、色々試してやっとまともに聞ける音質になったので、試行錯誤の形跡を残しておくとともに、音声サンプルを貼っておきます。ガチ勢の方はゆるりと見守ってください</p>

<p>基本的に、以下の論文を参考にしています</p>

<ul>
<li><a href="http://isw3.naist.jp/~tomoki/Tomoki/Journals/IEEE-Nov-2007_MLVC.pdf">T. Toda, A. W. Black, and K. Tokuda, “Voice conversion based on maximum likelihood estimation of spectral parameter trajectory,” IEEE Trans. Audio, Speech, Lang. Process, vol. 15, no. 8, pp. 2222–2235, Nov. 2007</a>.</li>
</ul>


<h2>GMMベースの声質変換の基本</h2>

<p>シンプルなGMMベースの声質変換は大きく二つのフェーズに分けられます。</p>

<ul>
<li>参照話者と目標話者のスペクトル特徴量の結合GMM $P(x,y)$を学習する</li>
<li>入力$x$が与えらたとき、$P(y|x)$が最大となるようにスペクトル特徴量を変換する</li>
</ul>


<p>あらかじめ話者間の関係をデータから学習しておくことで、未知の入力が来た時にも変換が可能になるわけです。</p>

<p>具体的な変換プロセスとしては、音声を</p>

<ul>
<li>基本周波数</li>
<li>非周期性成分</li>
<li>スペクトル包絡</li>
</ul>


<p>の3つに分解し、スペクトル包絡の部分（≒声質を表す特徴量）に対して変換を行い、最後に波形を再合成するといった方法がよく用いられます。基本周波数や非周期性成分も変換することがありますが、ここではとりあえず扱いません</p>

<p>シンプルな方法では、フレームごとに独立に変換を行います。</p>

<p>GMMベースのポイントは、東大の齋藤先生の以下のツイートを引用しておきます。</p>

<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/shurabaP">@shurabaP</a> GMMベースの声質変換の肝は、入力xが与えられた時の出力yの条件付き確率P(y|x) が最大になるようにyを選ぶという確率的な考えです。私のショボい自作スクリプトですが、HTKを使ったGMMの学習レシピは研究室内部用に作ってあるので、もし必要なら公開しますよ。</p>&mdash; Daisuke Saito (@dsk_saito) <a href="https://twitter.com/dsk_saito/statuses/48442052534472706">March 17, 2011</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>ちなみに僕はscipy.mixture.GMMを使いました。HTKヤダー</p>

<h2>やってみる</h2>

<p>さて、実際にやってみます。データベースには、<a href="ht%0Atp://www.festvox.org/cmu_arctic/">CMU_ARCTIC speech synthesis databases</a>を使います。今回は、女性話者の二人を使いました。</p>

<p>音声の分析合成には、<a href="http://ml.cs.yamanashi.ac.jp/world/">WORLD</a>を使います。WORLDで求めたスペクトル包絡からメルケプストラム（今回は32次元）に変換したものを特徴量として使いました。</p>

<p>学習では、学習サンプル10641フレーム（23フレーズ）、GMMの混合数64、full-covarianceで学習しました。</p>

<h3>変換元となる話者（参照話者）</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157362625&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<h3>変換対象となる話者（目標話者）</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157362613&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<h3>GMMベースのframe-by-frameな声質変換の結果</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157371966&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>はぁー、正直聞けたもんじゃないですね。声質は目標話者に近づいている感がありますが、何分音質が悪い。学習条件を色々変えて試行錯誤しましたけどダメでした</p>

<h2>GMMベースの声質変換の弱点</h2>

<p>さて、なぜダメかを考えます。もう考えつくされてる感あるけど、大事なところだけ整理します</p>

<h3>フレーム毎に独立な変換処理</h3>

<p>まず、音声が時間的に独立なわけないですよね。フレームごとに独立に変換すると、時間的に不連続な点が出てきてしまいます。その結果、ちょっとノイジーな音声になってしまったのではないかと考えられます。</p>

<p>これに対する解決法としては、戸田先生の論文にあるように、動的特徴量も併せてGMMを学習して、系列全体の確率が最大となるように変換を考えるトラジェクトリベースのパラメータ生成方法があります。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>さて、やってみます。参照音声、目標音声は↑で使ったサンプルと同じです。</p>

<h3>トラジェクトリベースの声質変換の結果</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157371969&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>あんま変わらないですね。計算量めっちゃ食うのに、本当につらい。実装が間違ってる可能性もあるけど…</p>

<p>他の方法を考えるとするならば、まぁいっぱいあると思うんですが、スペクトル包絡なんて時間的に不連続にコロコロ変わるようなもんでもない気がするので、確率モデルとしてそういう依存関係を考慮した声質変換があってもいいもんですけどね。あんま見てない気がします。</p>

<p>ちょっと調べたら見つかったもの↓</p>

<ul>
<li><a href="http://koasas.kaist.ac.kr/bitstream/10203/17632/1/25.pdf">Kim, E.K., Lee, S., Oh, Y.-H. (1997). &ldquo;Hidden Markov Model Based Voice Conversion Using Dynamic Characteristics of Speaker&rdquo;, Proc. of Eurospeech’97, Rhodes, Greece, pp. 2519-2522.</a></li>
</ul>


<h3>過剰な平滑化</h3>

<p>これはGMMに限った話ではないですが、GMMベースのFrame-by-Frameな声質変換の場合でいえば、変換後の特徴量は条件付き期待値を取ることになるので、まぁ常識的に考えて平滑化されますよね。</p>

<p>これに対する解法としては、GV（Global Variance）を考慮する方法があります。これは戸田先生が提案されたものですね。</p>

<p>さて、やってみます。wktk</p>

<h3>GVを考慮したトラジェクトリベースの声質変換の結果</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157371971&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>多少ましになった気もしなくもないけど、やっぱり音質はいまいちですね。そして計算量は激マシします。本当につらい。学会で聞いたGVありの音声はもっと改善してた気がするんだけどなー音声合成の話だけど。僕の実装が間違ってるんですかね…</p>

<h2>ムズすぎわろた</h2>

<p>以上、いくつか試しましたが、統計的声質変換は激ムズだということがわかりました。え、ここで終わるの？という感じですが、最後に一つ別の手法を紹介します。</p>

<h2>差分スペクトル補正に基づく統計的声質変換</h2>

<p>これまでは、音声を基本周波数、非周期性成分、スペクトル包絡に分解して、スペクトル包絡を表す特徴量を変換し、変換後の特徴量を元に波形を再合成していました。ただ、よくよく考えると、そもそも基本周波数、非周期性成分をいじる必要がない場合であれば、わざわざ分解して再合成する必要なくね？声質の部分のみ変換するようなフィルタかけてやればよくね？という考えが生まれます。実は、そういったアイデアに基づく素晴らしい手法があります。それが、差分スペクトル補正に基づく声質変換です。</p>

<p>詳細は、以下の予稿をどうぞ</p>

<p><a href="http://www.phontron.com/paper/kobayashi14asj.pdf">小林 和弘, 戸田 智基, Graham Neubig, Sakriani Sakti, 中村 哲. &ldquo;差分スペクトル補正に基づく統計的歌声声質変換&rdquo;, 日本音響学会2014年春季研究発表会(ASJ). 東京. 2014年3月.</a></p>

<p>では、やってみます。歌声ではなく話し声ですが。他の声質変換の結果とも聴き比べてみてください。</p>

<h3>差分スペクトル補正に基づく声質変換の結果</h3>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/157362603&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>


<p>かなり音声の自然性は上がりましたね。これはヘタすると騙されるレベル。本当に素晴らしいです。しかも簡単にできるので、お勧めです。↑のは、GMMに基づくframe-by-frameな変換です。計算量も軽いので、リアルタイムでもいけますね。</p>

<h2>おわりに</h2>

<p>声質変換であれこれ試行錯誤して、ようやくスタートラインにたてた感があります。今後は新しい方法を考えようかなーと思ってます。</p>

<p>おわり</p>

<h2>おわび</h2>

<blockquote class="twitter-tweet" lang="en"><p>お盆の間に学習ベースの声質変換のプログラム書く（宿題） <a href="https://twitter.com/hashtag/%E5%AE%A3%E8%A8%80?src=hash">#宣言</a></p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/statuses/366928228465655808">August 12, 2013</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>約1年かかりました……。本当に申し訳ありませんでした(´･_･`)</p>

<h2>追記</h2>

<p>Twitterで教えてもらいました。トラジェクトリベースで学習も変換も行う研究もありました</p>

<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/r9y9">@r9y9</a> つ トラジェクトリＧＭＭな特徴量変換 <a href="http://t.co/kUn7bp9EUt">http://t.co/kUn7bp9EUt</a></p>&mdash; 縄文人（妖精系研究者なのです） (@dicekicker) <a href="https://twitter.com/dicekicker/statuses/485376823308455936">July 5, 2014</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>ただ、これはトラジェクトリベースのパラメータ生成法の提案であって、トラジェクトリモデル自体を学習してるわけではないんだよなー。普通に考えると学習もトラジェクトリで考える方法があっていい気がするが、 <del>まだ見てないですね。</del> ありました。追記参照<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GOSSP - Go言語で音声信号処理]]></title>
    <link href="http://r9y9.github.io/blog/2014/06/08/gossp-speech-signal-processing-for-go/"/>
    <updated>2014-06-08T00:56:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/06/08/gossp-speech-signal-processing-for-go</id>
    <content type="html"><![CDATA[<h1>C++からGoへ</h1>

<p>みなさん、C++で信号処理のアルゴリズムを書くのはつらいと思ったことはありませんか？C++で書くと速いのはいいけれど、いかんせん書くのが大変、コンパイルエラーは読みづらい、はたまたライブラリをビルドしようとしたら依存関係が上手く解決できず……そんな覚えはないでしょうか？謎のコンパイルエラーに悩みたくない、ガーベジコレクションほしい、Pythonのようにさくっと書きたい、型推論もほしい、でも動作は速い方がいい、そう思ったことはないでしょうか。</p>

<p>そこでGoです。もちろん、そういった思いに完全に答えてくれるわけではありませんが、厳しいパフォーマンスを要求される場合でなければ、Goの方が良い場合も多いと僕は思っています。
とはいえ、まだ比較的新しい言語のため、ライブラリは少なく信号処理を始めるのも大変です。というわけで、僕がC++をやめてGoに移行したことを思い出し、Goでの信号処理の基礎と、今まで整備してきたGoでの音声信号処理ライブラリを紹介します。</p>

<p>Goの良いところ/悪いところについては書きません。正直、本当は何の言語でもいいと思っていますが、僕はGoが好きなので、ちょっとでもGoで信号処理したいと思う人が増えるといいなーと思って書いてみます。</p>

<p>あとで書きますが、僕が書いたコードで使えそうなものは、以下にまとめました。</p>

<p><a href="https://github.com/r9y9/gossp">https://github.com/r9y9/gossp</a></p>

<h1>基礎</h1>

<h2>Wavファイルの読み込み/書き込み <a href="http://godoc.org/github.com/mjibson/go-dsp/wav">[wav]</a></h2>

<p><img class="center" src="http://r9y9.github.io/images/speech_signal.png" title="&#34;Speech signal example.&#34;" alt="&#34;Speech signal example.&#34;"></p>

<p>まずは音声ファイルの読み込みですね。wavファイルの読み込みさえできれば十分でしょう。</p>

<p>これは、すでに有用なライブラリが存在します。<a href="https://github.com/mjibson/go-dsp">GO-DSP</a> とういデジタル信号処理のライブラリに含まれるwavパッケージを使いましょう。</p>

<p>次のように書くことができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/mjibson/go-dsp/wav&quot;</span>
</span><span class='line'>  <span class="s">&quot;log&quot;</span>
</span><span class='line'>  <span class="s">&quot;os&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ファイルのオープン</span>
</span><span class='line'>  <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;./test.wav&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Wavファイルの読み込み </span>
</span><span class='line'>  <span class="nx">w</span><span class="p">,</span> <span class="nx">werr</span> <span class="o">:=</span> <span class="nx">wav</span><span class="p">.</span><span class="nx">ReadWav</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">werr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">werr</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// データを表示</span>
</span><span class='line'>  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Data</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>簡単ですね。</p>

<p>Goはウェブ周りの標準パッケージが充実しているので、以前<a href="http://qiita.com/r9y9/items/35a1cf139332a3072fc8">qiitaに書いた記事</a>のように、wavファイルを受け取って何らかの処理をする、みたいなサーバも簡単に書くことができます</p>

<p>wavファイルの書き込み＋ユーティリティを追加したかったので、僕は自分でカスタムしたパッケージを使っています。</p>

<p><a href="https://github.com/r9y9/go-dsp">https://github.com/r9y9/go-dsp</a></p>

<h2>高速フーリエ変換 (Fast Fourier Transform; FFT) <a href="http://godoc.org/github.com/mjibson/go-dsp/fft">[fft]</a></h2>

<p>言わずとしれたFFTです。音のスペクトルを求めるのに必須の処理です。で、Goではどうすればいいのか？ということですが、こちらもすでに有用なライブラリが存在します。<a href="https://github.com/mjibson/go-dsp">GO-DSP</a>に含まれる、fftパッケージを使いましょう。</p>

<p>このfftパッケージは、go routinesを使って平行化されているため速いです。僕は、1次元のフーリエ変換以外めったに使いませんが、N次元のフーリエ変換をサポートしているのもこのライブラリのいいところです。</p>

<h3>参考</h3>

<ul>
<li><a href="http://mattjibson.com/blog/2013/01/04/go-dsp-fft-performance-with-go-routines/">go-dsp FFT performance with go routines · Matt Jibson</a></li>
</ul>


<p>使い方は、とても簡単です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/mjibson/go-dsp/fft&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fft</span><span class="p">.</span><span class="nx">FFTReal</span><span class="p">([]</span><span class="kt">float64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>離散コサイン変換 (Discrete Cosine Transform; DCT) <a href="http://godoc.org/github.com/r9y9/gossp/dct">[dct]</a></h2>

<p>DCTは、Mel-Frequency Cepstrum Coefficients (通称MFCC) 求めるのに必要な変換です。こちらは、残念ながら良さそうなライブラリがなかったので、自分で書きました。</p>

<p>使い方はFFTとほとんど一緒です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/r9y9/gossp/dct&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">y</span> <span class="o">:=</span> <span class="nx">dct</span><span class="p">.</span><span class="nx">DCTOrthogonal</span><span class="p">([]</span><span class="kt">float64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">})</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">dct</span><span class="p">.</span><span class="nx">IDCTOrthogonal</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span> <span class="c1">// 直交変換では、逆変換すると元に戻る</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>さて、基本的なところは一旦ここまでです。次からは、少し音声寄りの信号処理手法の紹介です。</p>

<h1>時間周波数解析</h1>

<h2>短時間フーリエ変換 (Short Time Fourier Transform; STFT) <a href="http://godoc.org/github.com/r9y9/gossp/stft">[stft]</a></h2>

<p><img class="center" src="http://r9y9.github.io/images/stft.png" title="&#34;STFT spectrogram&#34;" alt="&#34;STFT spectrogram&#34;"></p>

<p>STFTは、音声の時間周波数解析手法として定番の方法ですね。音声を可視化したり、何らかの認識アルゴリズムの特徴抽出に使ったり、まぁ色々です。</p>

<p>次のようなコードを書くと、スペクトログラムが作れます</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;flag&quot;</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/r9y9/gossp&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/r9y9/gossp/io&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/r9y9/gossp/stft&quot;</span>
</span><span class='line'>  <span class="s">&quot;github.com/r9y9/gossp/window&quot;</span>
</span><span class='line'>  <span class="s">&quot;log&quot;</span>
</span><span class='line'>  <span class="s">&quot;math&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">filename</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;input.wav&quot;</span><span class="p">,</span> <span class="s">&quot;Input filename&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">w</span><span class="p">,</span> <span class="nx">werr</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWav</span><span class="p">(</span><span class="o">*</span><span class="nx">filename</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">werr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">werr</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">data</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">GetMonoData</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stft</span><span class="p">.</span><span class="nx">STFT</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">FrameShift</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">SampleRate</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">),</span> <span class="c1">// 0.01 sec,</span>
</span><span class='line'>      <span class="nx">FrameLen</span><span class="p">:</span>   <span class="mi">2048</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">Window</span><span class="p">:</span>     <span class="nx">window</span><span class="p">.</span><span class="nx">CreateHanning</span><span class="p">(</span><span class="mi">2048</span><span class="p">),</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">spectrogram</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">STFT</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">amplitudeSpectrogram</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">gossp</span><span class="p">.</span><span class="nx">SplitSpectrogram</span><span class="p">(</span><span class="nx">spectrogram</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">PrintMatrixAsGnuplotFormat</span><span class="p">(</span><span class="nx">amplitudeSpectrogram</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">PrintMatrixAsGnuplotFormat</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">))</span>
</span><span class='line'>  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">vec</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">matrix</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vec</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上の画像は、gnuplotで表示したものです</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">set</span> <span class="nx">pm3d</span> <span class="kd">map</span>
</span><span class='line'><span class="nx">sp</span> <span class="s">&quot;spectrogram.txt&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>逆短時間フーリエ変換 (Inverse Short Time Fourier Transform; ISTFT) <a href="http://godoc.org/github.com/r9y9/gossp/stft">[stft]</a></h2>

<p>ISTFTは、STFTの逆変換でスペクトログラムから時間領域の信号に戻すために使います。スペクトログラムを加工するような音源分離、ノイズ除去手法を使う場合には、必須の処理です。これはstftと同じパッケージ下にあります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="nx">reconstructed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ISTFT</span><span class="p">(</span><span class="nx">spectrogram</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>これで、スペクトログラムから音声を再構築することができます。</p>

<p>逆変換の仕組みは、意外と難しかったりします。</p>

<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.306.7858">D. W. Griffin and J. S. Lim, &ldquo;Signal estimation from modified short-time Fourier transform,&rdquo; IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</a></li>
<li><a href="http://research.cs.tamu.edu/prism/lectures/sp/l6.pdf">L6: Short-time Fourier analysis and synthesis</a></li>
<li><a href="http://yukara-13.hatenablog.com/entry/2013/11/17/210204">Pythonで短時間フーリエ変換（STFT）と逆変換 &ndash; 音楽プログラミングの超入門（仮）</a></li>
</ul>


<p>この辺を参考にしました。興味のある人は読んで見てください。</p>

<h2>連続ウェーブレット変換 (Continuous Wavelet Transform; CWT)</h2>

<p><img class="center" src="http://r9y9.github.io/images/morlet_6_log.png" title="&#34;Morlet Wavelet spectrogram&#34;" alt="&#34;Morlet Wavelet spectrogram&#34;"></p>

<p>これは何回かブログで書きました。</p>

<ul>
<li><a href="http://r9y9.github.io/blog/2013/10/20/continuous-wavelet-tranform/">FFTを使った連続ウェーブレット変換の高速化 &ndash; LESS IS MORE</a></li>
<li><a href="http://r9y9.github.io/blog/2014/06/01/continuouos-wavelet-transform-types/">連続ウェーブレット変換に使うマザーウェーブレット色々: Morlet, Paul, DOG &ndash; LESS IS MORE</a></li>
</ul>


<p>コードは、テストがまだ通らないので開発中ということで…orz</p>

<h2>逆連続ウェーブレット変換 (Inverse Continuous Wavelet Transform; ICWT)</h2>

<p>連続ウェーブレット変換の逆変換ですね。これもけっこう難しいです。こちらもまだテストに通っていないので、開発中です。</p>

<ul>
<li><a href="http://r9y9.github.io/blog/2013/10/21/signal-reconstruction-using-invere-cwt/">逆連続ウェーブレット変換による信号の再構成 &ndash; LESS IS MORE</a></li>
</ul>


<p>さて、この辺でまた一区切りです。次は、より音声に特化した信号処理手法を紹介します。</p>

<p>※以降紹介するもののうち、多くは<a href="http://sp-tk.sourceforge.net/">SPTK</a>のGo-portになっていて、一部はcgoを使ってラップしただけです（後々はpure goにしたいけれど、特にメルケプストラム分析あたりは難しいのでできていません）</p>

<h1>音声分析系</h1>

<h2>基本周波数推定 <a href="http://godoc.org/github.com/r9y9/gossp/f0">[f0]</a></h2>

<p><img class="center" src="http://r9y9.github.io/images/arayuru_f0.png" title="&#34;Fundamental frequency trajectory example.&#34;" alt="&#34;Fundamental frequency trajectory example.&#34;"></p>

<p>ざっくり言えば音の高さを求める方法ですね。一応、音声に特化した方法をいくつか使えるようにしました。</p>

<ul>
<li><a href="http://audition.ens.fr/adc/pdf/2002_JASA_YIN.pdf">A. de Cheveigne and H. Kawahara. YIN, a fundamental frequency estimator for speech and music. J. Acoust. Soc. Am., 111(4):1917–1930, 2002.</a></li>
<li><a href="http://www.cise.ufl.edu/~acamacho/publications/dissertation.pdf">A. Camacho. SWIPE: A sawtooth waveform inspired pitch estimator for speech and music. PhD thesis, University of Florida, 2007.</a></li>
</ul>


<p>ただしYINはもどきです。</p>

<p>以前、<a href="https://github.com/r9y9/go-world">GO-WORLD</a>という音声分析合成系WORLDのGoラッパーを書いたので、それを使えばF0推定手法Dioが使えます。</p>

<h3>参考</h3>

<ul>
<li><a href="http://r9y9.github.io/blog/2014/03/22/go-world/">音声分析変換合成システムWORLDのGoラッパーを書いた &ndash; LESS IS MORE</a></li>
</ul>


<h2>メルケプストラム分析 <a href="http://godoc.org/github.com/r9y9/gossp/mgcep">[mgcep]</a></h2>

<p>音声合成界隈ではよく聞くメルケプストラム（※MFCCとは異なります）を求めるための分析手法です。メルケプストラムは、HMM（Hidden Markov Models; 隠れマルコフモデル）音声合成や統計的声質変換において、声道特徴（いわゆる、声質）のパラメータ表現としてよく使われています。メルケプストラムの前に、LPCとかPARCORとか色々あるのですが、現在のHMM音声合成で最もよく使われているのはメルケプストラムな気がするので、メルケプストラム分析があれば十分な気がします。</p>

<p>これは、SPTKをcgoを使ってラップしました</p>

<h3>参考</h3>

<ul>
<li><a href="http://ci.nii.ac.jp/naid/40004638236/">徳田恵一, 小林隆夫, 深田俊明, 斎藤博徳, 今井 聖, “メルケプストラムをパラメータとする音声のスペクトル推定,” 信学論(A), vol.J74-A, no.8, pp.1240–1248, Aug. 1991.</a></li>
</ul>


<h2>メル一般化ケプストラム分析 <a href="http://godoc.org/github.com/r9y9/gossp/mgcep">[mgcep]</a></h2>

<p>メル一般化ケプストラム分析は、その名の通りメルケプストラム分析を一般化したものです。メルケプストラム分析はもちろん、LPCも包含します（詳細は、参考文献をチェックしてみてください）。論文をいくつかあさっている限り、あんまり使われていない気はしますが、これもSPTKをラップしてGoから使えるようにしました。メルケプストラム分析もメル一般化ケプストラム分析に含まれるので、mgcepという一つのパッケージにしました。</p>

<h3>参考</h3>

<ul>
<li><a href="http://www.utdallas.edu/~john.hanse/nPublications/JP-55-SpeechComm-Yapanel-Hansen-PMVDR-Feb08.pdf">Tokuda, K., Masuko, T., Kobayashi, T., Imai, S., 1994. Mel-generalized Cepstral Analysis-A Uniﬁed Approach to Speech Spectral Estimation, ISCA ICSLP-94: Inter. Conf. Spoken Lang. Proc., Yokohama, Japan, pp. 1043–1046.</a></li>
</ul>


<h1>音声合成系</h1>

<h2>励起信号の生成 <a href="http://godoc.org/github.com/r9y9/gossp/excite">[excite]</a></h2>

<p><img class="center" src="http://r9y9.github.io/images/pulse_excite.png" title="&#34;Exciation eignal.&#34;" alt="&#34;Exciation eignal.&#34;"></p>

<p>SPTKのexciteのGo実装です。いわゆるPulseExcitationという奴ですね。非周期成分まったく考慮しない単純な励起信号です。</p>

<p>高品質な波形合成が必要な場合は、WORLDやSTRAIGHTを使うのが良いです。</p>

<h2>MLSA (Mel Log Spectrum Approximation) デジタルフィルタ <a href="http://godoc.org/github.com/r9y9/gossp/vocoder">[vocoder]</a></h2>

<p>MLSAフィルタは、メルケプストラムと励起信号から音声波形を合成するためのデジタルフィルタです。HMM音声合成の波形合成部で使われています（今もきっと）。Pure goで書き直しました。</p>

<p>昔、C++でも書いたことあります。</p>

<h3>参考</h3>

<ul>
<li><a href="http://r9y9.github.io/blog/2013/12/01/mlsa-filter-with-c-plus-plus/">MLSA digital filter のC++実装 &ndash; LESS IS MORE</a></li>
</ul>


<h2>MGLSA (Mel Genaralized-Log Spectrum Approximation) デジタルフィルタ <a href="http://godoc.org/github.com/r9y9/gossp/vocoder">[vocoder]</a></h2>

<p>MGLSAフィルタは、メル一般化ケプストラムから波形を合成するためのデジタルフィルタですね。これも pure goで書きました。</p>

<h2><strong>※SPTKの再実装について</strong></h2>

<p>SPTKの実装をGoで書き直したものについては、SPTKの実装と結果が一致するかどうかを確認するテストを書いてあります。よって、誤った結果になるということは（計算誤差が影響する場合を除き）基本的にないので、お気になさらず。</p>

<h2>高品質な音声分析変換合成系 WORLD <a href="http://godoc.org/github.com/r9y9/go-world">[go-world]</a></h2>

<p><a href="http://r9y9.github.io/blog/2014/03/22/go-world/">音声分析変換合成システムWORLDのGoラッパーを書いた &ndash; LESS IS MORE</a></p>

<p>以前WORLDのGoラッパーを書いたので、色々使えると思います。統計ベースの音声合成とか、声質変換とか。僕は声質変換に使おうと思ってラップしました。</p>

<h1>おわりに</h1>

<p>長々と書きましたが、Go言語での信号処理の基礎と、今まで整備してきた音声信号処理ライブラリを簡単に紹介しました。僕が書いたものは、まとめてGithubで公開しています。</p>

<p><a href="https://github.com/r9y9/gossp">https://github.com/r9y9/gossp</a></p>

<p>使ってももらって、あわよくばバグとか報告してもらって、改善していければいいなーというのと、あとGithubのissue管理便利だし使おうと思ってGithubに上げました。</p>

<p>みなさん、Goで音声信号処理始めてみませんか？</p>

<h1>余談</h1>

<h2>Pythonではダメなの？その他言語は？</h2>

<p>なんでGoなの？と思う人がいると思います。冒頭にも書いたとおり、正直好きなのにすればいいですが、適当に書いて速いのがいいならC++だし、型を意識せずさくっと書きたいならPythonだし、そこそこ速くて型があって型推論もあって、とかだったらGoがいいかなと僕は思います。</p>

<p>Goの特徴（≒良さ）ついては、<a href="http://www.slideshare.net/ymotongpoo/20130228-gobp-study-66-16830134">20130228 Goノススメ（BPStudy #66） | SlideShare</a>
 の11枚目が僕にはドンピシャです。</p>

<p>numpy, scipy, matplotlib, scikit-learnあたりが最強すぎるので、僕はpythonも良く使います。</p>

<h2>きっかけ</h2>

<p>この記事を書いたきっかけは、友人にGoをおすすめしまくっていたのに全然聞いてくれなかったからでした。Goでも信号処理はできるよ</p>
]]></content>
  </entry>
  
</feed>
