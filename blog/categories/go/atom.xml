<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Go | LESS IS MORE]]></title>
  <link href="http://r9y9.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://r9y9.github.io/"/>
  <updated>2015-12-23T02:15:40+09:00</updated>
  <id>http://r9y9.github.io/</id>
  <author>
    <name><![CDATA[Ryuichi YAMAMOTO]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[cgo の基本的な使い方とポインタ周りのTips (Go v1.2)]]></title>
    <link href="http://r9y9.github.io/blog/2014/03/22/cgo-tips/"/>
    <updated>2014-03-22T23:17:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/03/22/cgo-tips</id>
    <content type="html"><![CDATA[<p>C/C++ライブラリのGoラッパーを書くためには、cgoというパッケージを使うのだけど、特にCのポインタ周りにハマりどころが多かったので、少しまとめとく</p>

<p>cgoの基礎については、以下の二つを読むことを推奨</p>

<ul>
<li><a href="http://golang.org/cmd/cgo/">http://golang.org/cmd/cgo/</a></li>
<li><a href="https://code.google.com/p/go-wiki/wiki/cgo">https://code.google.com/p/go-wiki/wiki/cgo</a></li>
</ul>


<p>この記事では、cgo基本的な使い方と、いくつかポインタ絡みのTipsをまとめる。Tipsのみ必要な場合は、最初の方は飛ばして下さい</p>

<h2>cgo</h2>

<blockquote><p>Cgo enables the creation of Go packages that call C code.</p></blockquote>

<p><a href="http://golang.org/cmd/cgo/">http://golang.org/cmd/cgo/</a></p>

<p>cgoとは、GoからCの関数/型にアクセスするために用いるパッケージのこと。cgoを使えば、GoからCのコードが呼べる。つまり、<strong>Cで書かれたライブラリが、Goでも再利用できる</strong>。</p>

<p>なお、go v1.2 から、C++もサポートされている様子
<a href="http://golang.org/doc/go1.2#cgo_and_cpp">http://golang.org/doc/go1.2#cgo_and_cpp</a></p>

<p>ただし、C++ライブラリの使用方法については現時点でドキュメントはほぼ無し。僕の経験では、extern &ldquo;C&rdquo; を付けておくとC++用のコンパイラでコンパイルされたライブラリでも呼べる</p>

<h2>基本的な使い方</h2>

<p>まず、Cの型/関数にアクセスするために、cgoパッケージのimportを行う</p>

<p><code>go
import "C"
</code></p>

<p>import文のすぐ上のコメントにinclude &lt;ヘッダ.h> と書けば、コンパイルする際に自動で読み込まれるので、必要なヘッダを書く</p>

<p><code>go
// #include &lt;stdio.h&gt;
// #include &lt;stdlib.h&gt;
import "C"
</code></p>

<p>これで、C.int, C.float, C.double, *C.char、C.malloc, C.free などのようにして、Cの型や関数にアクセスできる</p>

<h2>外部ライブラリを呼ぶ</h2>

<p>通常は、ヘッダファイルをincludeするだけでなく、何かしらのライブラリとリンクして用いることが多いので、そのような場合には、ライブラリの依存関係をgoのコードに記述する</p>

<p>cgoでは、includeの設定と同様に、CFLAGS、CPPFLAGS、CXXFLAGS、LDFLAGS、pkg-configを記述することができる</p>

<p>pkg-configを使うと 、</p>

<p><code>go
// #cgo pkg-config: png cairo
// #include &lt;png.h&gt;
import "C"
</code></p>

<p>こんな感じ（<a href="http://golang.org/cmd/cgo/">Goの公式ページ</a>から参照）</p>

<h2>Tips</h2>

<p>さて、ここからTips。主に、<a href="ml.cs.yamanashi.ac.jp/world/">WORLD</a>のGoラッパーを書いていたときに得た知見です。ラッパーは、<a href="https://github.com/r9y9/go-world">Github</a>にあげた</p>

<h2>1. GoのスライスをCのポインタとして関数の引数に渡す</h2>

<p>例えば、[]float64 &ndash;> double* のイメージ</p>

<p>これは比較的簡単にできる。以前qiitaにも書いた
<a href="http://qiita.com/r9y9/items/e6d879c9b7d4f2697593">http://qiita.com/r9y9/items/e6d879c9b7d4f2697593</a></p>

<p><code>go
(*C.double)(&amp;slice[0])
</code></p>

<p>のようにキャストしてやればOK</p>

<h2>2. GoのスライスのスライスをCのポインタのポインタとして関数の引数に渡す</h2>

<p>[][]float64 &ndash;> double** のようなイメージ</p>

<p>例として、worldから引っ張ってきた以下のようなCの関数を考える</p>

<p><code>c++
void Star(double *x, int x_length, int fs, double *time_axis, double *f0,
  int f0_length, double **spectrogram);
</code></p>

<p>**spectrogramには処理結果が格納される。もちろん処理結果はGoの型で扱いたいんだが、では<strong>**spectrogramにどうやってGoの型を渡すか？</strong>ということが問題になる</p>

<p>doubleの二次元配列なので、</p>

<p><code>go
s := [][]float64
</code></p>

<p>というスライスのスライスを考えて、キャストして渡したいところだけど、結論から言うとこれはできない</p>

<p>ではどうするかというと、苦肉の策として、
<code>go
wspace := make([]*C.double, len(f0))
</code></p>

<p>というスライスを考えて、</p>

<p><code>
(**C.double)(&amp;wspace[0])
</code></p>

<p>とすれば、double**として関数の引数に渡すことができる。他にも方法がある気がするが、これでも期待通りの動作をする（あまりハックっぽいことしたくない…</p>

<p>まとめると、</p>

<ul>
<li>[][]float64 &ndash;> double**はできないが、</li>
<li>[]*C.double &ndash;> double**はできる。よって、一応Goの型をdouble**に渡すことはできる</li>
</ul>


<p>です。</p>

<h2>3. ポインタのポインタからスライスのスライスへの変換</h2>

<p>double** &ndash;> [][]float64 のようなイメージ</p>

<p>Tipsその2の例より、Cの関数の処理が終われば**spectrogramにデータが格納される。もちろん処理結果はGoの型で扱いたいので、[][]float64 にしたい。ただし、先程の例では、Cの関数に渡した型は実際には []*C.doubleで、Cの型を含んでいる。</p>

<p>そこで、次に問題になるのは、<strong>[]*C.doubleにから[][]float64 に変換するにはどうするか？</strong>ということ。そして、これも面倒です…（※節の頭でdouble** &ndash;> [][]float64と書いたけど、正確には []*C.double &ndash;> [][]float64）</p>

<p>結論から言えば、直接の変換は難しいけど中間変数をかませばできる</p>

<ul>
<li>[]bytes型でtmp変数を作り、<code>C.GoBytes</code> を使って*C.double &ndash;> []bytes にコピー</li>
<li>encoding/binaryパッケージを使って、[]bytes &ndash;> []float64 に書き込み</li>
<li>この処理をsliceOfSlices[0], sliceOfSlices[1], &hellip; に対して繰り返す</li>
</ul>


<p>以上。とても面倒ですね…</p>

<p>さて、結局上のStarのラッパーは以下のようになった</p>

<p>```go
func Star(x []float64, fs int, timeAxis, f0 []float64) [][]float64 {</p>

<pre><code>FFTSize := C.size_t(C.GetFFTSizeForStar(C.int(fs)))
numFreqBins := FFTSize/2 + 1

// Create workspace
wspace := make([]*C.double, len(f0))
for i := range wspace {
    wspace[i] = (*C.double)(C.malloc(byteSizeOfFloat64 * numFreqBins))
    defer C.free(unsafe.Pointer(wspace[i]))
}

// Perform star
C.Star((*C.double)(&amp;x[0]),
    C.int(len(x)),
    C.int(fs),
    (*C.double)(&amp;timeAxis[0]),
    (*C.double)(&amp;f0[0]),
    C.int(len(f0)),
    (**C.double)(&amp;wspace[0]))

// Copy to go slice
spectrogram := make([][]float64, len(f0))
for i := range spectrogram {
    spectrogram[i] = CArrayToGoSlice(wspace[i], C.int(numFreqBins))
}

return spectrogram
</code></pre>

<p>}
```</p>

<p>上で使っているutility function</p>

<p>```go
func CArrayToGoSlice(array *C.double, length C.int) []float64 {</p>

<pre><code>slice := make([]float64, int(length))
b := C.GoBytes(unsafe.Pointer(array), C.int(byteSizeOfFloat64*length))
err := binary.Read(bytes.NewReader(b), binary.LittleEndian, slice)
if err != nil {
    panic(err)
}
return slice
</code></pre>

<p>}
```</p>

<ul>
<li>[]*C.double のスライスを作り、作業領域のメモリを確保する（Tips2の内容+メモリ確保）</li>
<li>[]*C.double のスライスをdouble** にキャストして、Cの関数を実行（Tips2の内容）</li>
<li>[]*C.double から[][]float64に変換する（Tips3の内容）</li>
</ul>


<p>という手順になってます</p>

<p><strong>※2013/03/27 追記</strong>
:もっとシンプルかつ効率的（copyの必要がないように）に書けた。[][]float64で返り値用のスライスを作り、それを[]<em>double型に変換してCに渡せば、[][]float64に変更が反映されるので、そもそも[]</em>doubleから[][]float64に変換する必要はなかった。</p>

<p>```go
func Star(x []float64, fs int, timeAxis, f0 []float64) [][]float64 {</p>

<pre><code>FFTSize := C.size_t(C.GetFFTSizeForStar(C.int(fs)))
numFreqBins := C.size_t(FFTSize/2 + 1)

spectrogram := make([][]float64, len(f0))
for i := range spectrogram {
    spectrogram[i] = make([]float64, numFreqBins)
}

spectrogramUsedInC := Make2DCArrayAlternative(spectrogram)

// Perform star
C.Star((*C.double)(&amp;x[0]),
    C.int(len(x)),
    C.int(fs),
    (*C.double)(&amp;timeAxis[0]),
    (*C.double)(&amp;f0[0]),
    C.int(len(f0)),
    (**C.double)(&amp;spectrogramUsedInC[0]))

return spectrogram
</code></pre>

<p>}
```</p>

<p>```go</p>

<p>func Make2DCArrayAlternative(matrix [][]float64) []*C.double {</p>

<pre><code>alternative := make([]*C.double, len(matrix))
for i := range alternative {
    // DO NOT free because the source slice is managed by Go
    alternative[i] = (*C.double)(&amp;matrix[i][0])
}
return alternative
</code></pre>

<p>}
```</p>

<h2>おわりに</h2>

<ul>
<li>ポインタのポインタを引数に取る関数のラップはめんどくさい</li>
<li>Goは使いやすいのに <del>cgoは使いにくい</del></li>
<li>cgoつらい</li>
<li>よりいい方法があれば教えて下さい</li>
</ul>


<h2>2014/08/10 追記</h2>

<p>cgo使いにくいと書いたけど、あとから考えてみればcgoさんまじ使いやすかったです（遅い</p>

<p>Juliaのccallはもっと使いやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[音声分析変換合成システムWORLDのGoラッパーを書いた]]></title>
    <link href="http://r9y9.github.io/blog/2014/03/22/go-world/"/>
    <updated>2014-03-22T18:28:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/03/22/go-world</id>
    <content type="html"><![CDATA[<h2>音声分析変換合成システムWORLD</h2>

<p>WORLDとは、山梨大学の森勢先生が作られている高品質な音声分析変換合成システムです。非常に高品質かつ高速に動作するのが良い所です。詳細は以下のURLへ</p>

<p><a href="http://ml.cs.yamanashi.ac.jp/world/">http://ml.cs.yamanashi.ac.jp/world/</a></p>

<p>オリジナルはC+＋で書かれていますが、Goからも使えるようにラッパーを書きました。非常にいいソフトウェアなので、もしよろしければどうぞ</p>

<h2>GO-WORLD</h2>

<p><a href="https://github.com/r9y9/go-world">https://github.com/r9y9/go-world</a></p>

<p>使い方について、ほんの少し解説を書きます</p>

<p>※ubuntu12.04でのみ動作確認してます。</p>

<h2>準備</h2>

<h3>1. WORLDのインストール</h3>

<p>まずWORLDをインストールする必要があります。公式のパッケージではinstallerに相当するものがなかったので、作りました</p>

<p><a href="https://github.com/r9y9/world">https://github.com/r9y9/world</a></p>

<p><code>bash
 ./waf configure &amp;&amp; ./waf
 sudo ./waf install
</code></p>

<p>でインストールできます。</p>

<p>なお、WORLDは最新版ではなく0.1.2としています。最新版にすると自分の環境でビルドコケてしまったので…</p>

<h3>2. GO-WORLDのインストール</h3>

<p><code>bash
go get github.com/r9y9/go-world
</code></p>

<p>簡単ですね！</p>

<h2>使い方</h2>

<h3>1. インポートする</h3>

<p><code>go
import "github.com/r9y9/go-world"
</code></p>

<h3>2. worldのインスタンスを作る</h3>

<p><code>go
w := world.New(sampleRate, framePeriod) // e.g. (44100, 5)
</code></p>

<h3>3. 好きなworldのメソッドを呼ぶ</h3>

<h4>基本周波数の推定: Dio</h4>

<p><code>go
timeAxis, f0 := w.Dio(input, w.NewDioOption()) // default option is used
</code></p>

<h4>スペクトル包絡の推定: Star</h4>

<p><code>go
spectrogram := w.Star(input, timeAxis, f0)
</code></p>

<h4>励起信号の推定: Platinum</h4>

<p><code>go
residual := w.Platinum(input, timeAxis, f0, spectrogram)
</code></p>

<h4>パラメータから音声の再合成: Synthesis</h4>

<p><code>go
synthesized := w.Synthesis(f0, spectrogram, residual, len(input))
</code></p>

<h2>使い方例.</h2>

<p>音声（wavファイル）を分析して、パラメータから音声を再合成する例を紹介します。80行弱と少し長いですがはっつけておきます</p>

<p>```go
package main</p>

<p>import (</p>

<pre><code>"flag"
"fmt"
"github.com/mjibson/go-dsp/wav"
"github.com/r9y9/go-world"
"log"
"os"
</code></pre>

<p>)</p>

<p>var defaultDioOption = world.DioOption{</p>

<pre><code>F0Floor:          80.0,
F0Ceil:           640.0,
FramePeriod:      5,
ChannelsInOctave: 4.0,
Speed:            6,
</code></pre>

<p>}</p>

<p>// 音声を基本周波数、スペクトル包絡、励起信号の三つに分解したあと、再合成します
func worldExample(input []float64, sampleRate int) []float64 {</p>

<pre><code>w := world.New(sampleRate, defaultDioOption.FramePeriod)

// 1. Fundamental frequency
timeAxis, f0 := w.Dio(input, defaultDioOption)

// 2. Spectral envelope
spectrogram := w.Star(input, timeAxis, f0)

// 3. Excitation spectrum
residual := w.Platinum(input, timeAxis, f0, spectrogram)

// 4. Synthesis
return w.Synthesis(f0, spectrogram, residual, len(input))
</code></pre>

<p>}</p>

<p>// 音声を基本周波数、スペクトル包絡、非周期成分の三つに分解したあと、再合成します
func worldExampleAp(input []float64, sampleRate int) []float64 {</p>

<pre><code>w := world.New(sampleRate, defaultDioOption.FramePeriod)

// 1. Fundamental frequency
timeAxis, f0 := w.Dio(input, defaultDioOption)

// 2. Spectral envelope
spectrogram := w.Star(input, timeAxis, f0)

// 3. Apiriodiciy
apiriodicity, targetF0 := w.AperiodicityRatio(input, f0)

// 4. Synthesis
return w.SynthesisFromAperiodicity(f0, spectrogram, apiriodicity, targetF0, len(input))
</code></pre>

<p>}</p>

<p>func GetMonoDataFromWavData(data [][]int) []float64 {</p>

<pre><code>y := make([]float64, len(data))
for i, val := range data {
    y[i] = float64(val[0])
}
return y
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>ifilename := flag.String("i", "default.wav", "Input filename")
flag.Parse()

// Read wav data
file, err := os.Open(*ifilename)
if err != nil {
    log.Fatal(err)
}
defer file.Close()

w, werr := wav.ReadWav(file)
if werr != nil {
    log.Fatal(werr)
}
input := GetMonoDataFromWavData(w.Data)
sampleRate := int(w.SampleRate)

synthesized := worldExample(input, sampleRate)
// synthesized := worldExampleAp(input, sampleRate)

for i, val := range synthesized {
    fmt.Println(i, val)
}
</code></pre>

<p>}
```</p>

<p>Goだとメモリ管理きにしなくていいしそこそこ速いし読みやすいし書きやすいし楽でいいですね（信者</p>

<h2>おわりに</h2>

<ul>
<li>GoはC++ほど速くはないですが、C++の何倍も書きやすいし読みやすい（メンテしやすい）ので、個人的にオススメです（パフォーマンスが厳しく要求される場合には、C++の方がいいかもしれません）</li>
<li>WORLD良いソフトウェアなので使いましょう</li>
</ul>


<h2>ちなみに</h2>

<p>元はと言えば、オレオレ基本周波数推定（YINもどき）が微妙に精度悪くて代替を探していたとき、</p>

<ul>
<li>SPTKのRAPTかSWIPE使おうかな…</li>
<li>RAPTもSWIPEもSPTK.hにインタフェースがない…</li>
<li>うわRAPTのコード意味わからん</li>
<li>SWIPEのコードまじ謎</li>
<li>後藤さんのPreFest実装しよう</li>
<li>あれ上手くいかない…orz</li>
<li>どうしようかな…</li>
</ul>


<p>となっていたときに、森勢先生が書いたと思われる以下の文献を見つけて、</p>

<p><a href="http://crestmuse.jp/handbookMI/pdf/2_2_PitchExtraction_Morise.pdf">2-2 基本周波数推定（歌声研究に関する視点から）</a></p>

<blockquote><p>本方法は，低域に雑音が存在する音声に対する推定は困難であるが，低域の雑音が存在しない音声の場合，SWIPE′ や NDF と実質的に同等の性能を達成しつつ，計算時間を SWIPE′の 1/42, NDF の 1/80 にまで低減可能である．</p></blockquote>

<p>あぁworld使おう（白目</p>

<p>となり、ラッパーを書くにいたりましたとさ、おしまい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goで音声信号処理をしたいのでSPTKのGoラッパーを書く]]></title>
    <link href="http://r9y9.github.io/blog/2014/02/10/sptk-go-wrapper/"/>
    <updated>2014-02-10T02:33:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/02/10/sptk-go-wrapper</id>
    <content type="html"><![CDATA[<p>2014/07/22 追記：<br/>
パッケージの一部として書きました（<a href="http://r9y9.github.io/blog/2014/06/08/gossp-speech-signal-processing-for-go/">GOSSP &ndash; Go言語で音声信号処理 &ndash; LESS IS MORE</a>を参照）。
SPTKのラップも含め、いくつかGoで信号処理アルゴリズムを実装したので、お求めの方はどうぞ</p>

<p>&mdash;</p>

<p>Goが最近オススメです（n度目</p>

<p>Goで音声信号処理をしたいけど、全部一から書くのは大変だし、既存の資産は出来るだけ再利用したい。というわけで、C言語製の<a href="http://sp-tk.sourceforge.net/">SPTK</a> をGoから使えるようにする</p>

<h2>cgo</h2>

<p>GoにはC言語のライブラリを使うには、cgoというパッケージを使えばできる。使い方は、公式のページ等を見るといいと思う <a href="http://golang.org/cmd/cgo/">http://golang.org/cmd/cgo/</a></p>

<p>Cの関数や変数などには、 <code>C.</code> でアクセスできる</p>

<h2>ラッパー</h2>

<p>例えば以下のように書く。MFCCの計算を例に上げる。必要に応じで<code>SPTK.h</code>に定義されている関数をラップする</p>

<p>```go
package sptk</p>

<p>// #cgo pkg-config: SPTK
// #include &lt;stdio.h>
// #include &lt;SPTK/SPTK.h>
import &ldquo;C&rdquo;</p>

<p>func MFCC(audioBuffer []float64, sampleRate int, alpha, eps float64, wlng, flng, m, n, ceplift int, dftmode, usehamming bool) []float64 {</p>

<pre><code>// Convert go bool to C.Boolean (so annoying..
var dftmodeInGo, usehammingInGo C.Boolean
if dftmode {
    dftmodeInGo = 1
} else {
    dftmodeInGo = 0
}
if usehamming {
    usehammingInGo = 1
} else {
    usehammingInGo = 0
}

resultBuffer := make([]float64, m)
C.mfcc((*_Ctype_double)(&amp;audioBuffer[0]), (*_Ctype_double)(&amp;resultBuffer[0]), C.double(sampleRate), C.double(alpha), C.double(eps), C.int(wlng), C.int(flng), C.int(m), C.int(n), C.int(ceplift), dftmodeInGo, usehammingInGo)
return resultBuffer
</code></pre>

<p>}
```</p>

<p>このパッケージを使う前に、 <a href="https://github.com/r9y9/SPTK">https://github.com/r9y9/SPTK</a> を使ってSPTKをインストールする。本家のを使ってもいいですが、その場合は #cgo の設定が変わると思います。公式のSPTK、pkg-configに対応してくれんかな…</p>

<p>最初は、LDFLAGS つけ忘れてて、symbol not foundってなってつらまった。次回から気をつけよう</p>

<p>SPTKの、特に（メル）ケプストラム分析当たりは本当に難しいので、論文読んで実装するのも大変だし中身がわからなくてもラップする方が合理的、という結論に至りました。簡単なもの（例えば、メルケプからMLSA filterの係数への変換とか）は、依存関係を少なくするためにもGo nativeで書きなおした方がいいです</p>

<p>コードは気が向いたら上げる</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goに関する良記事]]></title>
    <link href="http://r9y9.github.io/blog/2014/02/02/ready-to-use-go/"/>
    <updated>2014-02-02T16:57:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2014/02/02/ready-to-use-go</id>
    <content type="html"><![CDATA[<p>いくつか見つけたのでメモる</p>

<h2><a href="http://www.jellolabs.com/blog/why-golang-is-ready-for-early-stage-startups.html">Why We Think GoLang Is Ready For Early Stage Startups</a></h2>

<p>とあるスタートアップがウェブでGoを使うという意思決定をした理由、その決断に至るまでのプロセスが書かれている。また、その過程でGoを使うことによる利点・欠点が簡潔にまとめられてる。参考になった</p>

<h2><a href="https://kidoman.com/programming/go-getter.html">Go Getter &ndash; Performance comparison to C++ business card ray tracer</a></h2>

<p><img class="center" src="/images/go-improvements.png"></p>

<p>GoとC++のパフォーマンスの比較。Ray tracingというCGの手法を用いて比較をしていて、Goでも最適化するとC++並のスピード出ますよ（そしてC++と違ってGCあるしマルチコアにも簡単にできるしGoいいよ）って話。（自分へのメモのため画像を拝借していますが、意味がわからないと思うので元記事を参照してください）</p>

<p>ただoptimized Go vs un-optimized C++なので注意。Goの最適化が主旨の記事です</p>

<h2><a href="https://kidoman.com/programming/go-getter-part-2.html">Go Getter Part 2 &ndash; Now with C++ optimizations</a></h2>

<p><img class="center" src="/images/go-vs-cpp-after-both-optimized.png"></p>

<p>さっきの続きで、こちらでは最適化したC++と比較されてる。OpenMP使って並列化してるようだけど、あれ、まだC++の方が遅い・・（正直意外</p>

<h2><a href="https://kidoman.com/programming/go-getter-part-3.html">Go Getter Part 3 &ndash; Further optimizations and a multi-threaded C++ version</a></h2>

<p><img class="center" src="/images/2048x2048-3.png"></p>

<p>これで最後。C++（とGo）をめちゃくちゃ最適化した、って奴ですね。C++の方が二倍程度速くなったよう。
ただ、やっぱC++の方が良かった、というよりGoがC++並になるのも時間の問題って感じですね。</p>

<h2>さて</h2>

<p>このまとめで何が言いたかったというと</p>

<p><strong>「Goを使わない選択肢がない」</strong></p>

<p>まぁ半分冗談（ケースバイケースだし）ですが、僕のようにC++をメインで使っているけど不満ありまくりな人は、一度Go使ってみてもいいんじゃないでしょうか、と思います。C++の百倍書きやすいです</p>
]]></content>
  </entry>
  
</feed>
