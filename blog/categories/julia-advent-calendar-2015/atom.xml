<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Julia-Advent-Calendar-2015 | LESS IS MORE]]></title>
  <link href="http://r9y9.github.io/blog/categories/julia-advent-calendar-2015/atom.xml" rel="self"/>
  <link href="http://r9y9.github.io/"/>
  <updated>2015-12-23T01:12:48+09:00</updated>
  <id>http://r9y9.github.io/</id>
  <author>
    <name><![CDATA[Ryuichi YAMAMOTO]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cxx.jl を使ってみた感想 + OpenCV.jl, Libfreenect2.jl の紹介]]></title>
    <link href="http://r9y9.github.io/blog/2015/12/22/cxx-jl/"/>
    <updated>2015-12-22T00:23:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/12/22/cxx-jl</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/opencvjl_demo.jpg" title="&ldquo;OpenCV.jl based on Cxx.jl&rdquo;" ></p>

<h2>はじめに</h2>

<p><a href="http://qiita.com/advent-calendar/2015/julialang">Julia Advent Calendar 2015</a> 22日目の記事です。</p>

<p>Julia の C++ FFI (Fourign Function Interface) である <a href="https://github.com/Keno/Cxx.jl">Cxx.jl</a> をしばらく使ってみたので、その感想を書きます。加えて、Cxx.jl を使って作った成果物の話も簡単に書こうと思います（冒頭に貼った画像は、OpenCV.jl でテキトーにカメラから画像をキャプチャしてthresholdingしたやつです）。
Cxx.jl の動作原理については、僕の理解が不十分なため簡単にしか紹介できませんが、そもそも使ったことがある人が稀だと思われるので、感想程度でも役に立てば幸いです。</p>

<h2>Cxx.jl とは</h2>

<p><a href="https://github.com/Keno/Cxx.jl">https://github.com/Keno/Cxx.jl</a></p>

<p>簡単に説明すると、Cxx.jl とは、Julia から C++ を使用する（e.g. 関数呼び出し、メソッド呼び出し、メンバ変数へのアクセス、etc) ための機能を提供するパッケージです。C++のライブラリを活用したい、あるいはパフォーマンスがシビアな箇所で一部 C++ 使いたい（Cインタフェースを作りたくない<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>）、といった場合に便利です。</p>

<p>Cxx.jl の原理についてざっくりといえば、clang を用いて C++ から LLVM IR を生成し、llvmcall を用いて（Just in time に）コードを実行する、という方式のようです<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Cxx.jl の原理について知りたい場合は、Cxx.jl のソースコード（+コメント）を、Cxx.jl を使うと何ができるのか知りたい場合は、Cxx.jl の README を御覧ください。</p>

<p>以下、過去を思い出しながら感想を書いてみます</p>

<h2>実際に使う前に</h2>

<h3>Pkg.build(&ldquo;Cxx&rdquo;) を成功させることが困難</h3>

<p>そもそも使いはじめる前に、ビルドすることが困難でした。Cxx.jl を動作させるためには、</p>

<ul>
<li>julia</li>
<li>llvm</li>
<li>clang</li>
<li>lldb</li>
</ul>


<p>の開発版が必要ですが、ビルドが難しい大きな原因は、動作することが保証された<strong>明確な revision が存在しない</strong>ことにあります。（なんじゃそれ、と思うかもしれませんが、まぁまだ安定版はリリースされていないので、、）</p>

<p>今でこそ、llvm, clang, lldbは、Keno氏の fork の kf/gallium ブランチ使えばいいよと README に書いてありますが、僕が使い始めた二ヶ月ほど前は、開発版のllvmが必要だよ、くらいにしか書いていませんでした（参考: <a href="https://github.com/Keno/Cxx.jl/blob/3897e8720b683fe35e407f2128d14e41cec8e0dd/README.md">Cxx.jl/README</a>）。何度もllvmをビルドし直すのは、本当に苦行でした…</p>

<p>参考：</p>

<blockquote class="twitter-tweet" lang="en"><p lang="ja" dir="ltr">今日だけでllvmをn回ビルドしてる（ビルドできたとは言ってない</p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/status/655000313112367104">October 16, 2015</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<br>


<p>思考停止の様子：</p>

<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">make -C deps clean-llvm &amp; make -j4</p>&mdash; 山本りゅういち (@r9y9) <a href="https://twitter.com/r9y9/status/670571501658251264">November 28, 2015</a></blockquote>


<script async src="http://r9y9.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<br>


<h3>Cxx.jl のビルドはどうするのが一番簡単なのか</h3>

<p>さて、さらっと書きましたが、今では llvm, clang, lldb　のkf/gallium　ブランチを使えば、比較的簡単に、多少の試行錯誤<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> で Cxx.jl をビルドして使えます。</p>

<h3>開発版 llvm と一緒に Julia をビルドする</h3>

<p>Juliaをクローンしたディレクトリで、以下の様な <code>Make.user</code> ファイルを作成して make します。</p>

<p>```
override LLDB_VER=master
override LLVM_VER=svn
override LLVM_ASSERTIONS=1
override BUILD_LLVM_CLANG=1
override BUILD_LLDB=1
override USE_LLVM_SHLIB=1
override LLDB_DISABLE_PYTHON=1</p>

<p>override LLVM_GIT_URL_LLVM=<a href="https://github.com/JuliaLang/llvm.git">https://github.com/JuliaLang/llvm.git</a>
override LLVM_GIT_URL_LLDB=<a href="https://github.com/JuliaLang/lldb.git">https://github.com/JuliaLang/lldb.git</a>
override LLVM_GIT_URL_CLANG=<a href="https://github.com/JuliaLang/clang.git">https://github.com/JuliaLang/clang.git</a>
override LLVM_GIT_VER=kf/gallium
override LLVM_GIT_VER_LLDB=kf/gallium
override LLVM_GIT_VER_CLANG=kf/gallium
```</p>

<p>一部、LLVM_ASSERSONS を有効にするなど、必ずしも必須でないものも含まれていますが、こちらが現状の推奨のようです。この設定で、僕はubuntu 14.04, osx 10.10 でビルドが通ることを確認しました<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<p>注意：すでに llvm や clang がローカルにクローン済の場合、<code>deps/srccache</code> 以下からクローン済みのソースを消してからビルドすることをおすすめします。すでにクローンされていて、upstream  の変更を取り入れたい場合は、</p>

<p><code>bash
make -C deps update-llvm
</code></p>

<p>とすると便利です。</p>

<h3>Cxx.jl のインストール</h3>

<p><code>jl
Pkg.clone("https://github.com/Keno/Cxx.jl.git")
Pkg.build("Cxx")   
</code></p>

<p>エラーがでなければ、インストール完了<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>です。</p>

<h2>実際に使ってみたあと</h2>

<p>さて、ようやくビルドもできて、ここからは使ってしばらくしての感想です。</p>

<h3>Julia 上で C++ の syntax がそのまま使える</h3>

<p>まず、簡単に Cxx.jl の機能を挙げると、重要なのは</p>

<ul>
<li><code>cxx"..."</code></li>
<li><code>icxx"..."</code></li>
<li><code>@cxx</code></li>
</ul>


<p>の三つです。以下、簡単に例をあげると、<code>cxx"..."</code> でC++ syntax を評価して：</p>

<p>```cpp
cxx"#include <iostream>"</p>

<p>cxx"&ldquo;&rdquo;
namespace test {
void f() {</p>

<pre><code>std::cout &lt;&lt; "Hello C++" &lt;&lt; std::endl;
</code></pre>

<p>}
}
&ldquo;&rdquo;&ldquo;
```</p>

<p><code>@cxx</code> マクロで C++ 関数を呼び出す：</p>

<p><code>jl
@cxx test::f()  # Hello C++
</code></p>

<p><code>cxx"..."</code>はグローバルスコープで評価されますが、<code>icxx"..."</code> を使えば、特定のスコープ内で C++ を使用することもできます。</p>

<p>```jl
for i in 1:10</p>

<pre><code>icxx"""std::cout &lt;&lt; $i &lt;&lt; std::endl;"""
</code></pre>

<p>end
```</p>

<p><code>ccall</code> のように、返り値、引数の型などを指定して実行するのではなく、C++ のsyntax をそのまま使ってコードが書ける、という点にびっくりしました。</p>

<h3>template も使える</h3>

<p><code>cpp
cxx"""
template &lt;typename T&gt;
T add(T x, T y) { return x + y; }
"""
</code></p>

<p>こんな感じで特殊化も可能</p>

<p><code>cpp
cxx"""
template &lt;&gt;
int add&lt;int&gt;(int x, int y) { return x + y; }
"""
</code></p>

<p>書いてて気付きましたが、README には template について言及されていませんね。僕は、今のところ問題なく使えています。例には出していませんが、template class ももちろん使えます（例. <code>std::vector&lt;T&gt;</code>）。</p>

<h3>その他雑記</h3>

<ul>
<li>Cxx.jl で使える C++ には制約がある（はず）だが、ここ二ヶ月使用した限りでは、大きな制約に出会ってないし、快適</li>
<li>共有ライブラリの呼び出しは、<code>ccall</code> と違ってライブラリだけでなくヘッダーファイルも必要</li>
<li><code>using Cxx</code> にはけっこう時間がかかる。僕の環境では約15秒だった</li>
<li>たまに llvm error を吐いて落ちる。デバッグするには llvm, clang についてある程度知識がないと難しそう</li>
<li>C++ REPL 便利</li>
</ul>


<p>という感じですかね。書き進むに連れて適当になってすいません、、、</p>

<h2>Cxx.jl を使って作った成果物</h2>

<p>まとめに入る前に、Cxx.jl を使って遊ぶ過程で作った成果物を、簡単なコメント付きで紹介します。</p>

<h3>OpenCV.jl</h3>

<p><img class="center" src="/images/video_thresholding.gif" title="&ldquo;OpenCV.jl demo&rdquo;" ></p>

<p><a href="https://github.com/r9y9/OpenCV.jl">https://github.com/r9y9/OpenCV.jl</a></p>

<p>Cxx.jl の学習の題材として作りました。途中から cv::Mat 周りを真面目に作り始めたので、それなりに使えると思います。</p>

<p>デザインポリシーとして、</p>

<ul>
<li>cv::Mat を <code>AbstractArray{T,N}</code> の subtype として Julia ライクに使えること</li>
<li>cv::Mat と Julia の Array の相互変換をサポートすること</li>
</ul>


<p>を念頭において作りました。</p>

<h3>LibFreenect2.jl</h3>

<p><img class="center" src="/images/depth_streaming_example.gif" title="&ldquo;LibFreenect2.jl demo&rdquo;" ></p>

<p><a href="https://github.com/r9y9/LibFreenect2.jl">https://github.com/r9y9/LibFreenect2.jl</a></p>

<p>ちょうど仕事で kinect v2 を触っていたので、遊びがてらやってみました。</p>

<h2>まとめ</h2>

<ul>
<li>Cxx.jl をビルドするのはけっこう面倒ですが、C++を（主観ですが）ほとんど不自由なくJITライクに使えるので、非常に便利です</li>
<li>二つほど C++ ライブラリのラッパーを作ってみましたが、簡単にできるので、みなさんもお試しあれ</li>
<li>レッツ・トライ Cxx.jl！</li>
</ul>


<h2>おまけ</h2>

<p>現在 Julia community では、llvm 3.3 から llvm 3.7.1 に移行しようとする動きがあるので（ref: <a href="https://github.com/JuliaLang/julia/issues/9336">julia/issues/9336</a>, <a href="https://github.com/JuliaLang/julia/pull/14430">julia/pull/14430</a>）、移行後は、もう少しビルドが楽になるかもしれません。</p>

<p>実は、この記事を読んでも、きっと今は　Cxx.jl をビルドできないんじゃないかなと思うんですが、もしどうしてもビルドしたい、ということであれば、僕のローカルの llvm, clang, lldb, julia の revision を調べて教えるので、言ってください。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>例えば template を多用している場合、Cインタフェースを作るのは面倒です<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>※正確に理解していないため、あまり宛てにしないでください）<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>多少の試行錯誤、というのは、Julia と Cxx.jl のリビジョンは、経験的には必ずしも（特にJuliaの）masterで動作しないので、Julia と Cxx.jl を master から少し遡って、ビルドできるか試行錯誤する、という意味です<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>ビルドが通ったことがある、の方が正確ですが<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>なお、現状のJulia masterとCxx.jl masterでは、エラーが出ると踏んでおります、、、<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Julia: 値と変数に対する Type Annotation の違い]]></title>
    <link href="http://r9y9.github.io/blog/2015/12/08/julia-type-annotations/"/>
    <updated>2015-12-08T00:01:00+09:00</updated>
    <id>http://r9y9.github.io/blog/2015/12/08/julia-type-annotations</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p><a href="http://qiita.com/advent-calendar/2015/julialang">Julia Advent Calendar 2015</a> 8日目の記事です。</p>

<p>この記事では、値 (value) と変数 (variable) に対する type annotation の違いを、問題とそれに対する解答を用意する形式で説明しようと思います。そんなの知ってるぜ！という方は、問題だけ解いてみて自分の理解度を試してもらえればと思います。</p>

<p>記事に出てくるJuliaコードは、Julia 0.5-dev, 0.4.0 で動作確認しました。</p>

<h2>問題</h2>

<p>新規REPLセッションを開いて、A、B それぞれを実行したときの挙動はどうなるでしょうか？エラーの発生の有無と、エラーが発生しない場合は返り値の値、型を答えてください。</p>

<h3>A</h3>

<p>```jl
function f()</p>

<pre><code>x = (1.0 + 2.0)::Int
return x
</code></pre>

<p>end</p>

<p>f()
```</p>

<h3>B</h3>

<p>```jl
function g()</p>

<pre><code>x::Int = (1.0 + 2.0)
return x
</code></pre>

<p>end</p>

<p>g()
```</p>

<p>なお、一方ではエラーが起き、もう一方はエラー無く実行されます。一見似たような書き方ですが、二つは異なる意味を持ちます。この記事ではそれぞれを解説しようと思います。</p>

<p>この問題の答えがわからなかった方は、この記事を読むと正解がわかるはずなので、続きをご覧ください。下の方に、簡潔な問題の解答とおまけ問題を書いておきました。</p>

<h2>A: 値に対する type annotation</h2>

<p>Aの2行目では、値に対して type annotation をしています。これは typeassert とも呼びます。Aで使った type annotation を日本語で説明してみると、「<code>(1.0 + 2.0)</code> という式を評価した値は、Int 型であることを保証する」となります。</p>

<p><code>(1.0 + 2.0)</code> を評価した値は <code>3.0</code> であり、 Float64の型を持ちます。したがって <code>Float64 != Int</code> であるため、</p>

<p><code>
ERROR: TypeError: typeassert: expected Int64, got Float64
</code></p>

<p>のような typeassert のエラーが吐かれます。</p>

<p><code>(1.0 + 2.0)</code>を評価した値の型は一見して明らかため、実用的な例ではありませんが、例えば関数の返り値の型は一見してわからないことがあるので、例えば以下のような書き方は有用な場合もあると思います。</p>

<p><code>jl
x = f(y)::Int
</code></p>

<h2>B: 変数に対する type annotation</h2>

<p>Bの2行目では、変数に対して type annotation をしています。同じく日本語で説明すると、「<code>x</code>という変数に入る値は、Int 型であることを保証する」となります。また、値に対する annotation とは異なり<strong>スコープ</strong>を持ちます。</p>

<p>前述したとおり、<code>(1.0 + 2.0)</code> を評価した値は <code>3.0</code> であり、Float64の型を持ちます。一方で、<code>x</code> は Int型の値を持つ変数として宣言されているため、この場合、Float64型である <code>(1.0 + 2.0)</code> を、Int 型に変換するような処理が<strong>暗黙的に</strong>行われます。したがって、変換可能な場合には（B の例がそうです）、エラーは起きません。暗黙的に処理が行われるというのは、知らないと予期せぬバグに遭遇することになるため、気をつける必要があります。</p>

<p>では、変数に対する type annotation はどのような場合に使うかというと、あるスコープの範囲で、代入によって変数の型が変わってしまうのを防ぐために使います。ある変数の型がスコープの範囲で不変というのはコンパイラにとっては嬉しい事で、パフォーマンスの向上に繋がります。Performance tips にもありますね（参考: <a href="http://docs.julialang.org/en/release-0.4/manual/performance-tips/#avoid-changing-the-type-of-a-variable">Performance tips / Avoid changing the type of a variable</a>）</p>

<h2>違いまとめ</h2>

<p>ここまでの話から、違いをまとめると、以下のようになります。</p>

<table>
<thead>
<tr>
<th> Type annotation の種類      </th>
<th> typeassert error　 </th>
<th> 暗黙的な型変換　 </th>
<th> スコープ　</th>
</tr>
</thead>
<tbody>
<tr>
<td> 値に対する type annotation   </td>
<td> あり             </td>
<td> なし           </td>
<td> なし</td>
</tr>
<tr>
<td> 変数に対する type annotation 　 </td>
<td> なし             </td>
<td> あり           </td>
<td> あり</td>
</tr>
</tbody>
</table>


<br>


<h2>最後に</h2>

<p>type annotation を使うときは、値と変数に対する annotation の違いを意識して、使い分けましょう</p>

<h2>問題の解答</h2>

<ul>
<li>A: typeassert に引っかかり、TypeError が吐かれる</li>
<li>B: Int 型の 3 が返り値として得られる</li>
</ul>


<h2>おまけ問題</h2>

<h3>1</h3>

<p>```jl
function h()</p>

<pre><code>x::UInt8 = UInt8(0)
x = Float64(0.0)
x
</code></pre>

<p>end
```</p>

<p>```jl</p>

<h1>なんと表示されるでしょうか？</h1>

<p>println(typeof(h()))
```</p>

<h3>2</h3>

<p>```jl
function s()</p>

<pre><code>x::Int = Float64(0)
x = UInt8(0)
x = Float32(0.5)
x
</code></pre>

<p>end
```</p>

<p>```jl</p>

<h1>なんと表示されるでしょうか？</h1>

<p>s()
```</p>

<p>解答は、各自REPLで実行して確認してみてください。長々と読んでくださりありがとうございました。</p>

<h2>参考</h2>

<ul>
<li><a href="http://docs.julialang.org/en/release-0.4/manual/types/?highlight=typeassert#type-declarations">公式ドキュメント / Type Declarations</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
